Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMILLA

Grammar

Rule 0     S' -> programa
Rule 1     programa -> PROGRAM ID addP SEMICOLON programa1
Rule 2     addP -> <empty>
Rule 3     programa1 -> vars modules programa2
Rule 4     programa1 -> vars modules
Rule 5     programa1 -> programa2
Rule 6     programa2 -> main
Rule 7     main -> MAIN LPAREN param RPAREN LCURLY vars statement RCURLY END
Rule 8     tipo -> INT
Rule 9     tipo -> FLOAT
Rule 10    tipo -> CHAR
Rule 11    vars -> var
Rule 12    vars -> empty
Rule 13    var -> VAR var2
Rule 14    var1 -> ID
Rule 15    var1 -> ID COMMA var1
Rule 16    var1 -> ID arr
Rule 17    var1 -> ID arr COMMA var1
Rule 18    var1 -> ID mat COMMA var1
Rule 19    var1 -> ID mat
Rule 20    var1 -> ID mat especial
Rule 21    var1 -> empty
Rule 22    var2 -> var2 tipo var1 SEMICOLON
Rule 23    var2 -> var2 tipo arr SEMICOLON
Rule 24    var2 -> var2 tipo mat SEMICOLON
Rule 25    var2 -> empty
Rule 26    especial -> TRANSPUESTA
Rule 27    especial -> INVERSA
Rule 28    especial -> DETERMINANTE
Rule 29    arr -> LBRACKET CTEI RBRACKET
Rule 30    arr -> LBRACKET exp RBRACKET
Rule 31    mat -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET
Rule 32    mat -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET
Rule 33    mat -> LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET
Rule 34    mat -> LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET
Rule 35    modules -> function modules
Rule 36    modules -> empty
Rule 37    function -> FUN VOID function1
Rule 38    function -> FUN INT function2
Rule 39    function -> FUN CHAR function2
Rule 40    function -> FUN FLOAT function2
Rule 41    save_fun -> <empty>
Rule 42    function1 -> ID save_fun LPAREN param RPAREN SEMICOLON LCURLY vars statement RCURLY
Rule 43    function2 -> ID save_fun LPAREN param RPAREN SEMICOLON LCURLY vars statement RETURN exp SEMICOLON RCURLY
Rule 44    statement -> statement1 statement
Rule 45    statement -> empty
Rule 46    statement1 -> asignacion SEMICOLON
Rule 47    statement1 -> llamada SEMICOLON
Rule 48    statement1 -> lectura SEMICOLON
Rule 49    statement1 -> escritura SEMICOLON
Rule 50    statement1 -> for
Rule 51    statement1 -> if
Rule 52    statement1 -> while
Rule 53    asignacion -> ID EQUALS exp
Rule 54    asignacion -> ID arr EQUALS exp
Rule 55    asignacion -> ID mat EQUALS exp
Rule 56    param -> tipo param1
Rule 57    param -> empty
Rule 58    param1 -> ID
Rule 59    param1 -> ID COMMA param1
Rule 60    param1 -> empty
Rule 61    llamada -> ID LPAREN exp RPAREN
Rule 62    if -> IF LPAREN exp RPAREN LCURLY statement RCURLY
Rule 63    if -> IF LPAREN exp RPAREN LCURLY statement RCURLY else
Rule 64    else -> ELSE LCURLY statement RCURLY
Rule 65    else -> empty
Rule 66    for -> FOR LPAREN for1 RPAREN LCURLY statement RCURLY
Rule 67    for1 -> FROM asignacion TO exp
Rule 68    while -> WHILE LPAREN exp RPAREN LCURLY statement RCURLY
Rule 69    escritura -> PRINT LPAREN escritura1 RPAREN
Rule 70    escritura1 -> escritura2 COMMA escritura2
Rule 71    escritura1 -> escritura2
Rule 72    escritura2 -> CTESTRING
Rule 73    escritura2 -> CTEI
Rule 74    escritura2 -> CTEF
Rule 75    escritura2 -> exp
Rule 76    lectura -> READ LPAREN var1 RPAREN
Rule 77    exp -> nexp
Rule 78    exp -> nexp OR nexp
Rule 79    nexp -> compexp
Rule 80    nexp -> compexp AND compexp
Rule 81    compexp -> sumexp
Rule 82    compexp -> compexp1 sumexp
Rule 83    compexp1 -> sumexp GT sumexp
Rule 84    compexp1 -> sumexp LT sumexp
Rule 85    compexp1 -> sumexp GTE sumexp
Rule 86    compexp1 -> sumexp LTE sumexp
Rule 87    compexp1 -> sumexp NE sumexp
Rule 88    sumexp -> mulexp
Rule 89    sumexp -> mulexp PLUS mulexp
Rule 90    sumexp -> mulexp MINUS mulexp
Rule 91    mulexp -> pexp
Rule 92    mulexp -> pexp MUL pexp
Rule 93    mulexp -> pexp DIV pexp
Rule 94    pexp -> var1
Rule 95    pexp -> CTEI
Rule 96    pexp -> CTEF
Rule 97    pexp -> CTEC
Rule 98    pexp -> llamada
Rule 99    pexp -> LPAREN exp RPAREN
Rule 100   empty -> <empty>

Terminals, with rules where they appear

AND                  : 80
CHAR                 : 10 39
COMILLA              : 
COMMA                : 15 17 18 59 70
CTEC                 : 97
CTEF                 : 74 96
CTEI                 : 29 31 31 33 34 73 95
CTESTRING            : 72
DETERMINANTE         : 28
DIV                  : 93
ELSE                 : 64
END                  : 7
EQUALS               : 53 54 55
FLOAT                : 9 40
FOR                  : 66
FROM                 : 67
FUN                  : 37 38 39 40
GT                   : 83
GTE                  : 85
ID                   : 1 14 15 16 17 18 19 20 42 43 53 54 55 58 59 61
IF                   : 62 63
INT                  : 8 38
INVERSA              : 27
LBRACKET             : 29 30 31 31 32 32 33 33 34 34
LCURLY               : 7 42 43 62 63 64 66 68
LPAREN               : 7 42 43 61 62 63 66 68 69 76 99
LT                   : 84
LTE                  : 86
MAIN                 : 7
MINUS                : 90
MUL                  : 92
NE                   : 87
OR                   : 78
PLUS                 : 89
PRINT                : 69
PROGRAM              : 1
RBRACKET             : 29 30 31 31 32 32 33 33 34 34
RCURLY               : 7 42 43 62 63 64 66 68
READ                 : 76
RETURN               : 43
RPAREN               : 7 42 43 61 62 63 66 68 69 76 99
SEMICOLON            : 1 22 23 24 42 43 43 46 47 48 49
TO                   : 67
TRANSPUESTA          : 26
VAR                  : 13
VOID                 : 37
WHILE                : 68
error                : 

Nonterminals, with rules where they appear

addP                 : 1
arr                  : 16 17 23 54
asignacion           : 46 67
compexp              : 79 80 80
compexp1             : 82
else                 : 63
empty                : 12 21 25 36 45 57 60 65
escritura            : 49
escritura1           : 69
escritura2           : 70 70 71
especial             : 20
exp                  : 30 32 32 33 34 43 53 54 55 61 62 63 67 68 75 99
for                  : 50
for1                 : 66
function             : 35
function1            : 37
function2            : 38 39 40
if                   : 51
lectura              : 48
llamada              : 47 98
main                 : 6
mat                  : 18 19 20 24 55
modules              : 3 4 35
mulexp               : 88 89 89 90 90
nexp                 : 77 78 78
param                : 7 42 43
param1               : 56 59
pexp                 : 91 92 92 93 93
programa             : 0
programa1            : 1
programa2            : 3 5
save_fun             : 42 43
statement            : 7 42 43 44 62 63 64 66 68
statement1           : 44
sumexp               : 81 82 83 83 84 84 85 85 86 86 87 87
tipo                 : 22 23 24 56
var                  : 11
var1                 : 15 17 18 22 76 94
var2                 : 13 22 23 24
vars                 : 3 4 7 42 43
while                : 52

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . PROGRAM ID addP SEMICOLON programa1

    PROGRAM         shift and go to state 2

    programa                       shift and go to state 1

state 1

    (0) S' -> programa .



state 2

    (1) programa -> PROGRAM . ID addP SEMICOLON programa1

    ID              shift and go to state 3


state 3

    (1) programa -> PROGRAM ID . addP SEMICOLON programa1
    (2) addP -> .

    SEMICOLON       reduce using rule 2 (addP -> .)

    addP                           shift and go to state 4

state 4

    (1) programa -> PROGRAM ID addP . SEMICOLON programa1

    SEMICOLON       shift and go to state 5


state 5

    (1) programa -> PROGRAM ID addP SEMICOLON . programa1
    (3) programa1 -> . vars modules programa2
    (4) programa1 -> . vars modules
    (5) programa1 -> . programa2
    (11) vars -> . var
    (12) vars -> . empty
    (6) programa2 -> . main
    (13) var -> . VAR var2
    (100) empty -> .
    (7) main -> . MAIN LPAREN param RPAREN LCURLY vars statement RCURLY END

  ! shift/reduce conflict for MAIN resolved as shift
    VAR             shift and go to state 12
    FUN             reduce using rule 100 (empty -> .)
    $end            reduce using rule 100 (empty -> .)
    MAIN            shift and go to state 13

  ! MAIN            [ reduce using rule 100 (empty -> .) ]

    programa1                      shift and go to state 6
    vars                           shift and go to state 7
    programa2                      shift and go to state 8
    var                            shift and go to state 9
    empty                          shift and go to state 10
    main                           shift and go to state 11

state 6

    (1) programa -> PROGRAM ID addP SEMICOLON programa1 .

    $end            reduce using rule 1 (programa -> PROGRAM ID addP SEMICOLON programa1 .)


state 7

    (3) programa1 -> vars . modules programa2
    (4) programa1 -> vars . modules
    (35) modules -> . function modules
    (36) modules -> . empty
    (37) function -> . FUN VOID function1
    (38) function -> . FUN INT function2
    (39) function -> . FUN CHAR function2
    (40) function -> . FUN FLOAT function2
    (100) empty -> .

    FUN             shift and go to state 17
    MAIN            reduce using rule 100 (empty -> .)
    $end            reduce using rule 100 (empty -> .)

    modules                        shift and go to state 14
    function                       shift and go to state 15
    empty                          shift and go to state 16

state 8

    (5) programa1 -> programa2 .

    $end            reduce using rule 5 (programa1 -> programa2 .)


state 9

    (11) vars -> var .

    FUN             reduce using rule 11 (vars -> var .)
    MAIN            reduce using rule 11 (vars -> var .)
    $end            reduce using rule 11 (vars -> var .)
    ID              reduce using rule 11 (vars -> var .)
    READ            reduce using rule 11 (vars -> var .)
    PRINT           reduce using rule 11 (vars -> var .)
    FOR             reduce using rule 11 (vars -> var .)
    IF              reduce using rule 11 (vars -> var .)
    WHILE           reduce using rule 11 (vars -> var .)
    RCURLY          reduce using rule 11 (vars -> var .)
    RETURN          reduce using rule 11 (vars -> var .)


state 10

    (12) vars -> empty .

    FUN             reduce using rule 12 (vars -> empty .)
    MAIN            reduce using rule 12 (vars -> empty .)
    $end            reduce using rule 12 (vars -> empty .)
    ID              reduce using rule 12 (vars -> empty .)
    READ            reduce using rule 12 (vars -> empty .)
    PRINT           reduce using rule 12 (vars -> empty .)
    FOR             reduce using rule 12 (vars -> empty .)
    IF              reduce using rule 12 (vars -> empty .)
    WHILE           reduce using rule 12 (vars -> empty .)
    RCURLY          reduce using rule 12 (vars -> empty .)
    RETURN          reduce using rule 12 (vars -> empty .)


state 11

    (6) programa2 -> main .

    $end            reduce using rule 6 (programa2 -> main .)


state 12

    (13) var -> VAR . var2
    (22) var2 -> . var2 tipo var1 SEMICOLON
    (23) var2 -> . var2 tipo arr SEMICOLON
    (24) var2 -> . var2 tipo mat SEMICOLON
    (25) var2 -> . empty
    (100) empty -> .

    INT             reduce using rule 100 (empty -> .)
    FLOAT           reduce using rule 100 (empty -> .)
    CHAR            reduce using rule 100 (empty -> .)
    FUN             reduce using rule 100 (empty -> .)
    MAIN            reduce using rule 100 (empty -> .)
    $end            reduce using rule 100 (empty -> .)
    ID              reduce using rule 100 (empty -> .)
    READ            reduce using rule 100 (empty -> .)
    PRINT           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    RCURLY          reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)

    var2                           shift and go to state 18
    empty                          shift and go to state 19

state 13

    (7) main -> MAIN . LPAREN param RPAREN LCURLY vars statement RCURLY END

    LPAREN          shift and go to state 20


state 14

    (3) programa1 -> vars modules . programa2
    (4) programa1 -> vars modules .
    (6) programa2 -> . main
    (7) main -> . MAIN LPAREN param RPAREN LCURLY vars statement RCURLY END

    $end            reduce using rule 4 (programa1 -> vars modules .)
    MAIN            shift and go to state 13

    programa2                      shift and go to state 21
    main                           shift and go to state 11

state 15

    (35) modules -> function . modules
    (35) modules -> . function modules
    (36) modules -> . empty
    (37) function -> . FUN VOID function1
    (38) function -> . FUN INT function2
    (39) function -> . FUN CHAR function2
    (40) function -> . FUN FLOAT function2
    (100) empty -> .

    FUN             shift and go to state 17
    MAIN            reduce using rule 100 (empty -> .)
    $end            reduce using rule 100 (empty -> .)

    function                       shift and go to state 15
    modules                        shift and go to state 22
    empty                          shift and go to state 16

state 16

    (36) modules -> empty .

    MAIN            reduce using rule 36 (modules -> empty .)
    $end            reduce using rule 36 (modules -> empty .)


state 17

    (37) function -> FUN . VOID function1
    (38) function -> FUN . INT function2
    (39) function -> FUN . CHAR function2
    (40) function -> FUN . FLOAT function2

    VOID            shift and go to state 23
    INT             shift and go to state 24
    CHAR            shift and go to state 25
    FLOAT           shift and go to state 26


state 18

    (13) var -> VAR var2 .
    (22) var2 -> var2 . tipo var1 SEMICOLON
    (23) var2 -> var2 . tipo arr SEMICOLON
    (24) var2 -> var2 . tipo mat SEMICOLON
    (8) tipo -> . INT
    (9) tipo -> . FLOAT
    (10) tipo -> . CHAR

    FUN             reduce using rule 13 (var -> VAR var2 .)
    MAIN            reduce using rule 13 (var -> VAR var2 .)
    $end            reduce using rule 13 (var -> VAR var2 .)
    ID              reduce using rule 13 (var -> VAR var2 .)
    READ            reduce using rule 13 (var -> VAR var2 .)
    PRINT           reduce using rule 13 (var -> VAR var2 .)
    FOR             reduce using rule 13 (var -> VAR var2 .)
    IF              reduce using rule 13 (var -> VAR var2 .)
    WHILE           reduce using rule 13 (var -> VAR var2 .)
    RCURLY          reduce using rule 13 (var -> VAR var2 .)
    RETURN          reduce using rule 13 (var -> VAR var2 .)
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    CHAR            shift and go to state 30

    tipo                           shift and go to state 27

state 19

    (25) var2 -> empty .

    INT             reduce using rule 25 (var2 -> empty .)
    FLOAT           reduce using rule 25 (var2 -> empty .)
    CHAR            reduce using rule 25 (var2 -> empty .)
    FUN             reduce using rule 25 (var2 -> empty .)
    MAIN            reduce using rule 25 (var2 -> empty .)
    $end            reduce using rule 25 (var2 -> empty .)
    ID              reduce using rule 25 (var2 -> empty .)
    READ            reduce using rule 25 (var2 -> empty .)
    PRINT           reduce using rule 25 (var2 -> empty .)
    FOR             reduce using rule 25 (var2 -> empty .)
    IF              reduce using rule 25 (var2 -> empty .)
    WHILE           reduce using rule 25 (var2 -> empty .)
    RCURLY          reduce using rule 25 (var2 -> empty .)
    RETURN          reduce using rule 25 (var2 -> empty .)


state 20

    (7) main -> MAIN LPAREN . param RPAREN LCURLY vars statement RCURLY END
    (56) param -> . tipo param1
    (57) param -> . empty
    (8) tipo -> . INT
    (9) tipo -> . FLOAT
    (10) tipo -> . CHAR
    (100) empty -> .

    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    CHAR            shift and go to state 30
    RPAREN          reduce using rule 100 (empty -> .)

    param                          shift and go to state 31
    tipo                           shift and go to state 32
    empty                          shift and go to state 33

state 21

    (3) programa1 -> vars modules programa2 .

    $end            reduce using rule 3 (programa1 -> vars modules programa2 .)


state 22

    (35) modules -> function modules .

    MAIN            reduce using rule 35 (modules -> function modules .)
    $end            reduce using rule 35 (modules -> function modules .)


state 23

    (37) function -> FUN VOID . function1
    (42) function1 -> . ID save_fun LPAREN param RPAREN SEMICOLON LCURLY vars statement RCURLY

    ID              shift and go to state 35

    function1                      shift and go to state 34

state 24

    (38) function -> FUN INT . function2
    (43) function2 -> . ID save_fun LPAREN param RPAREN SEMICOLON LCURLY vars statement RETURN exp SEMICOLON RCURLY

    ID              shift and go to state 37

    function2                      shift and go to state 36

state 25

    (39) function -> FUN CHAR . function2
    (43) function2 -> . ID save_fun LPAREN param RPAREN SEMICOLON LCURLY vars statement RETURN exp SEMICOLON RCURLY

    ID              shift and go to state 37

    function2                      shift and go to state 38

state 26

    (40) function -> FUN FLOAT . function2
    (43) function2 -> . ID save_fun LPAREN param RPAREN SEMICOLON LCURLY vars statement RETURN exp SEMICOLON RCURLY

    ID              shift and go to state 37

    function2                      shift and go to state 39

state 27

    (22) var2 -> var2 tipo . var1 SEMICOLON
    (23) var2 -> var2 tipo . arr SEMICOLON
    (24) var2 -> var2 tipo . mat SEMICOLON
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (29) arr -> . LBRACKET CTEI RBRACKET
    (30) arr -> . LBRACKET exp RBRACKET
    (31) mat -> . LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET
    (32) mat -> . LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (33) mat -> . LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET
    (34) mat -> . LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET
    (100) empty -> .

    ID              shift and go to state 43
    LBRACKET        shift and go to state 45
    SEMICOLON       reduce using rule 100 (empty -> .)

    var1                           shift and go to state 40
    arr                            shift and go to state 41
    mat                            shift and go to state 42
    empty                          shift and go to state 44

state 28

    (8) tipo -> INT .

    ID              reduce using rule 8 (tipo -> INT .)
    LBRACKET        reduce using rule 8 (tipo -> INT .)
    SEMICOLON       reduce using rule 8 (tipo -> INT .)
    RPAREN          reduce using rule 8 (tipo -> INT .)


state 29

    (9) tipo -> FLOAT .

    ID              reduce using rule 9 (tipo -> FLOAT .)
    LBRACKET        reduce using rule 9 (tipo -> FLOAT .)
    SEMICOLON       reduce using rule 9 (tipo -> FLOAT .)
    RPAREN          reduce using rule 9 (tipo -> FLOAT .)


state 30

    (10) tipo -> CHAR .

    ID              reduce using rule 10 (tipo -> CHAR .)
    LBRACKET        reduce using rule 10 (tipo -> CHAR .)
    SEMICOLON       reduce using rule 10 (tipo -> CHAR .)
    RPAREN          reduce using rule 10 (tipo -> CHAR .)


state 31

    (7) main -> MAIN LPAREN param . RPAREN LCURLY vars statement RCURLY END

    RPAREN          shift and go to state 46


state 32

    (56) param -> tipo . param1
    (58) param1 -> . ID
    (59) param1 -> . ID COMMA param1
    (60) param1 -> . empty
    (100) empty -> .

    ID              shift and go to state 48
    RPAREN          reduce using rule 100 (empty -> .)

    param1                         shift and go to state 47
    empty                          shift and go to state 49

state 33

    (57) param -> empty .

    RPAREN          reduce using rule 57 (param -> empty .)


state 34

    (37) function -> FUN VOID function1 .

    FUN             reduce using rule 37 (function -> FUN VOID function1 .)
    MAIN            reduce using rule 37 (function -> FUN VOID function1 .)
    $end            reduce using rule 37 (function -> FUN VOID function1 .)


state 35

    (42) function1 -> ID . save_fun LPAREN param RPAREN SEMICOLON LCURLY vars statement RCURLY
    (41) save_fun -> .

    LPAREN          reduce using rule 41 (save_fun -> .)

    save_fun                       shift and go to state 50

state 36

    (38) function -> FUN INT function2 .

    FUN             reduce using rule 38 (function -> FUN INT function2 .)
    MAIN            reduce using rule 38 (function -> FUN INT function2 .)
    $end            reduce using rule 38 (function -> FUN INT function2 .)


state 37

    (43) function2 -> ID . save_fun LPAREN param RPAREN SEMICOLON LCURLY vars statement RETURN exp SEMICOLON RCURLY
    (41) save_fun -> .

    LPAREN          reduce using rule 41 (save_fun -> .)

    save_fun                       shift and go to state 51

state 38

    (39) function -> FUN CHAR function2 .

    FUN             reduce using rule 39 (function -> FUN CHAR function2 .)
    MAIN            reduce using rule 39 (function -> FUN CHAR function2 .)
    $end            reduce using rule 39 (function -> FUN CHAR function2 .)


state 39

    (40) function -> FUN FLOAT function2 .

    FUN             reduce using rule 40 (function -> FUN FLOAT function2 .)
    MAIN            reduce using rule 40 (function -> FUN FLOAT function2 .)
    $end            reduce using rule 40 (function -> FUN FLOAT function2 .)


state 40

    (22) var2 -> var2 tipo var1 . SEMICOLON

    SEMICOLON       shift and go to state 52


state 41

    (23) var2 -> var2 tipo arr . SEMICOLON

    SEMICOLON       shift and go to state 53


state 42

    (24) var2 -> var2 tipo mat . SEMICOLON

    SEMICOLON       shift and go to state 54


state 43

    (14) var1 -> ID .
    (15) var1 -> ID . COMMA var1
    (16) var1 -> ID . arr
    (17) var1 -> ID . arr COMMA var1
    (18) var1 -> ID . mat COMMA var1
    (19) var1 -> ID . mat
    (20) var1 -> ID . mat especial
    (29) arr -> . LBRACKET CTEI RBRACKET
    (30) arr -> . LBRACKET exp RBRACKET
    (31) mat -> . LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET
    (32) mat -> . LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (33) mat -> . LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET
    (34) mat -> . LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET

  ! shift/reduce conflict for COMMA resolved as shift
    SEMICOLON       reduce using rule 14 (var1 -> ID .)
    MUL             reduce using rule 14 (var1 -> ID .)
    DIV             reduce using rule 14 (var1 -> ID .)
    PLUS            reduce using rule 14 (var1 -> ID .)
    MINUS           reduce using rule 14 (var1 -> ID .)
    GT              reduce using rule 14 (var1 -> ID .)
    LT              reduce using rule 14 (var1 -> ID .)
    GTE             reduce using rule 14 (var1 -> ID .)
    LTE             reduce using rule 14 (var1 -> ID .)
    NE              reduce using rule 14 (var1 -> ID .)
    AND             reduce using rule 14 (var1 -> ID .)
    OR              reduce using rule 14 (var1 -> ID .)
    RBRACKET        reduce using rule 14 (var1 -> ID .)
    RPAREN          reduce using rule 14 (var1 -> ID .)
    TO              reduce using rule 14 (var1 -> ID .)
    CTEI            reduce using rule 14 (var1 -> ID .)
    CTEF            reduce using rule 14 (var1 -> ID .)
    CTEC            reduce using rule 14 (var1 -> ID .)
    LPAREN          reduce using rule 14 (var1 -> ID .)
    ID              reduce using rule 14 (var1 -> ID .)
    COMMA           shift and go to state 55
    LBRACKET        shift and go to state 45

  ! COMMA           [ reduce using rule 14 (var1 -> ID .) ]

    arr                            shift and go to state 56
    mat                            shift and go to state 57

state 44

    (21) var1 -> empty .

    SEMICOLON       reduce using rule 21 (var1 -> empty .)
    MUL             reduce using rule 21 (var1 -> empty .)
    DIV             reduce using rule 21 (var1 -> empty .)
    PLUS            reduce using rule 21 (var1 -> empty .)
    MINUS           reduce using rule 21 (var1 -> empty .)
    GT              reduce using rule 21 (var1 -> empty .)
    LT              reduce using rule 21 (var1 -> empty .)
    GTE             reduce using rule 21 (var1 -> empty .)
    LTE             reduce using rule 21 (var1 -> empty .)
    NE              reduce using rule 21 (var1 -> empty .)
    AND             reduce using rule 21 (var1 -> empty .)
    OR              reduce using rule 21 (var1 -> empty .)
    RBRACKET        reduce using rule 21 (var1 -> empty .)
    RPAREN          reduce using rule 21 (var1 -> empty .)
    TO              reduce using rule 21 (var1 -> empty .)
    COMMA           reduce using rule 21 (var1 -> empty .)
    CTEI            reduce using rule 21 (var1 -> empty .)
    CTEF            reduce using rule 21 (var1 -> empty .)
    CTEC            reduce using rule 21 (var1 -> empty .)
    LPAREN          reduce using rule 21 (var1 -> empty .)
    ID              reduce using rule 21 (var1 -> empty .)


state 45

    (29) arr -> LBRACKET . CTEI RBRACKET
    (30) arr -> LBRACKET . exp RBRACKET
    (31) mat -> LBRACKET . CTEI RBRACKET LBRACKET CTEI RBRACKET
    (32) mat -> LBRACKET . exp RBRACKET LBRACKET exp RBRACKET
    (33) mat -> LBRACKET . exp RBRACKET LBRACKET CTEI RBRACKET
    (34) mat -> LBRACKET . CTEI RBRACKET LBRACKET exp RBRACKET
    (77) exp -> . nexp
    (78) exp -> . nexp OR nexp
    (79) nexp -> . compexp
    (80) nexp -> . compexp AND compexp
    (81) compexp -> . sumexp
    (82) compexp -> . compexp1 sumexp
    (88) sumexp -> . mulexp
    (89) sumexp -> . mulexp PLUS mulexp
    (90) sumexp -> . mulexp MINUS mulexp
    (83) compexp1 -> . sumexp GT sumexp
    (84) compexp1 -> . sumexp LT sumexp
    (85) compexp1 -> . sumexp GTE sumexp
    (86) compexp1 -> . sumexp LTE sumexp
    (87) compexp1 -> . sumexp NE sumexp
    (91) mulexp -> . pexp
    (92) mulexp -> . pexp MUL pexp
    (93) mulexp -> . pexp DIV pexp
    (94) pexp -> . var1
    (95) pexp -> . CTEI
    (96) pexp -> . CTEF
    (97) pexp -> . CTEC
    (98) pexp -> . llamada
    (99) pexp -> . LPAREN exp RPAREN
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (61) llamada -> . ID LPAREN exp RPAREN
    (100) empty -> .

    CTEI            shift and go to state 58
    CTEF            shift and go to state 67
    CTEC            shift and go to state 68
    LPAREN          shift and go to state 70
    ID              shift and go to state 71
    MUL             reduce using rule 100 (empty -> .)
    DIV             reduce using rule 100 (empty -> .)
    PLUS            reduce using rule 100 (empty -> .)
    MINUS           reduce using rule 100 (empty -> .)
    GT              reduce using rule 100 (empty -> .)
    LT              reduce using rule 100 (empty -> .)
    GTE             reduce using rule 100 (empty -> .)
    LTE             reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    RBRACKET        reduce using rule 100 (empty -> .)

    exp                            shift and go to state 59
    nexp                           shift and go to state 60
    compexp                        shift and go to state 61
    sumexp                         shift and go to state 62
    compexp1                       shift and go to state 63
    mulexp                         shift and go to state 64
    pexp                           shift and go to state 65
    var1                           shift and go to state 66
    llamada                        shift and go to state 69
    empty                          shift and go to state 44

state 46

    (7) main -> MAIN LPAREN param RPAREN . LCURLY vars statement RCURLY END

    LCURLY          shift and go to state 72


state 47

    (56) param -> tipo param1 .

    RPAREN          reduce using rule 56 (param -> tipo param1 .)


state 48

    (58) param1 -> ID .
    (59) param1 -> ID . COMMA param1

    RPAREN          reduce using rule 58 (param1 -> ID .)
    COMMA           shift and go to state 73


state 49

    (60) param1 -> empty .

    RPAREN          reduce using rule 60 (param1 -> empty .)


state 50

    (42) function1 -> ID save_fun . LPAREN param RPAREN SEMICOLON LCURLY vars statement RCURLY

    LPAREN          shift and go to state 74


state 51

    (43) function2 -> ID save_fun . LPAREN param RPAREN SEMICOLON LCURLY vars statement RETURN exp SEMICOLON RCURLY

    LPAREN          shift and go to state 75


state 52

    (22) var2 -> var2 tipo var1 SEMICOLON .

    INT             reduce using rule 22 (var2 -> var2 tipo var1 SEMICOLON .)
    FLOAT           reduce using rule 22 (var2 -> var2 tipo var1 SEMICOLON .)
    CHAR            reduce using rule 22 (var2 -> var2 tipo var1 SEMICOLON .)
    FUN             reduce using rule 22 (var2 -> var2 tipo var1 SEMICOLON .)
    MAIN            reduce using rule 22 (var2 -> var2 tipo var1 SEMICOLON .)
    $end            reduce using rule 22 (var2 -> var2 tipo var1 SEMICOLON .)
    ID              reduce using rule 22 (var2 -> var2 tipo var1 SEMICOLON .)
    READ            reduce using rule 22 (var2 -> var2 tipo var1 SEMICOLON .)
    PRINT           reduce using rule 22 (var2 -> var2 tipo var1 SEMICOLON .)
    FOR             reduce using rule 22 (var2 -> var2 tipo var1 SEMICOLON .)
    IF              reduce using rule 22 (var2 -> var2 tipo var1 SEMICOLON .)
    WHILE           reduce using rule 22 (var2 -> var2 tipo var1 SEMICOLON .)
    RCURLY          reduce using rule 22 (var2 -> var2 tipo var1 SEMICOLON .)
    RETURN          reduce using rule 22 (var2 -> var2 tipo var1 SEMICOLON .)


state 53

    (23) var2 -> var2 tipo arr SEMICOLON .

    INT             reduce using rule 23 (var2 -> var2 tipo arr SEMICOLON .)
    FLOAT           reduce using rule 23 (var2 -> var2 tipo arr SEMICOLON .)
    CHAR            reduce using rule 23 (var2 -> var2 tipo arr SEMICOLON .)
    FUN             reduce using rule 23 (var2 -> var2 tipo arr SEMICOLON .)
    MAIN            reduce using rule 23 (var2 -> var2 tipo arr SEMICOLON .)
    $end            reduce using rule 23 (var2 -> var2 tipo arr SEMICOLON .)
    ID              reduce using rule 23 (var2 -> var2 tipo arr SEMICOLON .)
    READ            reduce using rule 23 (var2 -> var2 tipo arr SEMICOLON .)
    PRINT           reduce using rule 23 (var2 -> var2 tipo arr SEMICOLON .)
    FOR             reduce using rule 23 (var2 -> var2 tipo arr SEMICOLON .)
    IF              reduce using rule 23 (var2 -> var2 tipo arr SEMICOLON .)
    WHILE           reduce using rule 23 (var2 -> var2 tipo arr SEMICOLON .)
    RCURLY          reduce using rule 23 (var2 -> var2 tipo arr SEMICOLON .)
    RETURN          reduce using rule 23 (var2 -> var2 tipo arr SEMICOLON .)


state 54

    (24) var2 -> var2 tipo mat SEMICOLON .

    INT             reduce using rule 24 (var2 -> var2 tipo mat SEMICOLON .)
    FLOAT           reduce using rule 24 (var2 -> var2 tipo mat SEMICOLON .)
    CHAR            reduce using rule 24 (var2 -> var2 tipo mat SEMICOLON .)
    FUN             reduce using rule 24 (var2 -> var2 tipo mat SEMICOLON .)
    MAIN            reduce using rule 24 (var2 -> var2 tipo mat SEMICOLON .)
    $end            reduce using rule 24 (var2 -> var2 tipo mat SEMICOLON .)
    ID              reduce using rule 24 (var2 -> var2 tipo mat SEMICOLON .)
    READ            reduce using rule 24 (var2 -> var2 tipo mat SEMICOLON .)
    PRINT           reduce using rule 24 (var2 -> var2 tipo mat SEMICOLON .)
    FOR             reduce using rule 24 (var2 -> var2 tipo mat SEMICOLON .)
    IF              reduce using rule 24 (var2 -> var2 tipo mat SEMICOLON .)
    WHILE           reduce using rule 24 (var2 -> var2 tipo mat SEMICOLON .)
    RCURLY          reduce using rule 24 (var2 -> var2 tipo mat SEMICOLON .)
    RETURN          reduce using rule 24 (var2 -> var2 tipo mat SEMICOLON .)


state 55

    (15) var1 -> ID COMMA . var1
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (100) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 43
    SEMICOLON       reduce using rule 100 (empty -> .)
    MUL             reduce using rule 100 (empty -> .)
    DIV             reduce using rule 100 (empty -> .)
    PLUS            reduce using rule 100 (empty -> .)
    MINUS           reduce using rule 100 (empty -> .)
    GT              reduce using rule 100 (empty -> .)
    LT              reduce using rule 100 (empty -> .)
    GTE             reduce using rule 100 (empty -> .)
    LTE             reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    RBRACKET        reduce using rule 100 (empty -> .)
    RPAREN          reduce using rule 100 (empty -> .)
    TO              reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    CTEI            reduce using rule 100 (empty -> .)
    CTEF            reduce using rule 100 (empty -> .)
    CTEC            reduce using rule 100 (empty -> .)
    LPAREN          reduce using rule 100 (empty -> .)

  ! ID              [ reduce using rule 100 (empty -> .) ]

    var1                           shift and go to state 76
    empty                          shift and go to state 44

state 56

    (16) var1 -> ID arr .
    (17) var1 -> ID arr . COMMA var1

  ! shift/reduce conflict for COMMA resolved as shift
    SEMICOLON       reduce using rule 16 (var1 -> ID arr .)
    MUL             reduce using rule 16 (var1 -> ID arr .)
    DIV             reduce using rule 16 (var1 -> ID arr .)
    PLUS            reduce using rule 16 (var1 -> ID arr .)
    MINUS           reduce using rule 16 (var1 -> ID arr .)
    GT              reduce using rule 16 (var1 -> ID arr .)
    LT              reduce using rule 16 (var1 -> ID arr .)
    GTE             reduce using rule 16 (var1 -> ID arr .)
    LTE             reduce using rule 16 (var1 -> ID arr .)
    NE              reduce using rule 16 (var1 -> ID arr .)
    AND             reduce using rule 16 (var1 -> ID arr .)
    OR              reduce using rule 16 (var1 -> ID arr .)
    RBRACKET        reduce using rule 16 (var1 -> ID arr .)
    RPAREN          reduce using rule 16 (var1 -> ID arr .)
    TO              reduce using rule 16 (var1 -> ID arr .)
    CTEI            reduce using rule 16 (var1 -> ID arr .)
    CTEF            reduce using rule 16 (var1 -> ID arr .)
    CTEC            reduce using rule 16 (var1 -> ID arr .)
    LPAREN          reduce using rule 16 (var1 -> ID arr .)
    ID              reduce using rule 16 (var1 -> ID arr .)
    COMMA           shift and go to state 77

  ! COMMA           [ reduce using rule 16 (var1 -> ID arr .) ]


state 57

    (18) var1 -> ID mat . COMMA var1
    (19) var1 -> ID mat .
    (20) var1 -> ID mat . especial
    (26) especial -> . TRANSPUESTA
    (27) especial -> . INVERSA
    (28) especial -> . DETERMINANTE

  ! shift/reduce conflict for COMMA resolved as shift
    COMMA           shift and go to state 78
    SEMICOLON       reduce using rule 19 (var1 -> ID mat .)
    MUL             reduce using rule 19 (var1 -> ID mat .)
    DIV             reduce using rule 19 (var1 -> ID mat .)
    PLUS            reduce using rule 19 (var1 -> ID mat .)
    MINUS           reduce using rule 19 (var1 -> ID mat .)
    GT              reduce using rule 19 (var1 -> ID mat .)
    LT              reduce using rule 19 (var1 -> ID mat .)
    GTE             reduce using rule 19 (var1 -> ID mat .)
    LTE             reduce using rule 19 (var1 -> ID mat .)
    NE              reduce using rule 19 (var1 -> ID mat .)
    AND             reduce using rule 19 (var1 -> ID mat .)
    OR              reduce using rule 19 (var1 -> ID mat .)
    RBRACKET        reduce using rule 19 (var1 -> ID mat .)
    RPAREN          reduce using rule 19 (var1 -> ID mat .)
    TO              reduce using rule 19 (var1 -> ID mat .)
    CTEI            reduce using rule 19 (var1 -> ID mat .)
    CTEF            reduce using rule 19 (var1 -> ID mat .)
    CTEC            reduce using rule 19 (var1 -> ID mat .)
    LPAREN          reduce using rule 19 (var1 -> ID mat .)
    ID              reduce using rule 19 (var1 -> ID mat .)
    TRANSPUESTA     shift and go to state 80
    INVERSA         shift and go to state 81
    DETERMINANTE    shift and go to state 82

  ! COMMA           [ reduce using rule 19 (var1 -> ID mat .) ]

    especial                       shift and go to state 79

state 58

    (29) arr -> LBRACKET CTEI . RBRACKET
    (31) mat -> LBRACKET CTEI . RBRACKET LBRACKET CTEI RBRACKET
    (34) mat -> LBRACKET CTEI . RBRACKET LBRACKET exp RBRACKET
    (95) pexp -> CTEI .

  ! shift/reduce conflict for RBRACKET resolved as shift
    RBRACKET        shift and go to state 83
    MUL             reduce using rule 95 (pexp -> CTEI .)
    DIV             reduce using rule 95 (pexp -> CTEI .)
    PLUS            reduce using rule 95 (pexp -> CTEI .)
    MINUS           reduce using rule 95 (pexp -> CTEI .)
    GT              reduce using rule 95 (pexp -> CTEI .)
    LT              reduce using rule 95 (pexp -> CTEI .)
    GTE             reduce using rule 95 (pexp -> CTEI .)
    LTE             reduce using rule 95 (pexp -> CTEI .)
    NE              reduce using rule 95 (pexp -> CTEI .)
    AND             reduce using rule 95 (pexp -> CTEI .)
    OR              reduce using rule 95 (pexp -> CTEI .)

  ! RBRACKET        [ reduce using rule 95 (pexp -> CTEI .) ]


state 59

    (30) arr -> LBRACKET exp . RBRACKET
    (32) mat -> LBRACKET exp . RBRACKET LBRACKET exp RBRACKET
    (33) mat -> LBRACKET exp . RBRACKET LBRACKET CTEI RBRACKET

    RBRACKET        shift and go to state 84


state 60

    (77) exp -> nexp .
    (78) exp -> nexp . OR nexp

    RBRACKET        reduce using rule 77 (exp -> nexp .)
    RPAREN          reduce using rule 77 (exp -> nexp .)
    SEMICOLON       reduce using rule 77 (exp -> nexp .)
    TO              reduce using rule 77 (exp -> nexp .)
    COMMA           reduce using rule 77 (exp -> nexp .)
    OR              shift and go to state 85


state 61

    (79) nexp -> compexp .
    (80) nexp -> compexp . AND compexp

    OR              reduce using rule 79 (nexp -> compexp .)
    RBRACKET        reduce using rule 79 (nexp -> compexp .)
    RPAREN          reduce using rule 79 (nexp -> compexp .)
    SEMICOLON       reduce using rule 79 (nexp -> compexp .)
    TO              reduce using rule 79 (nexp -> compexp .)
    COMMA           reduce using rule 79 (nexp -> compexp .)
    AND             shift and go to state 86


state 62

    (81) compexp -> sumexp .
    (83) compexp1 -> sumexp . GT sumexp
    (84) compexp1 -> sumexp . LT sumexp
    (85) compexp1 -> sumexp . GTE sumexp
    (86) compexp1 -> sumexp . LTE sumexp
    (87) compexp1 -> sumexp . NE sumexp

    AND             reduce using rule 81 (compexp -> sumexp .)
    OR              reduce using rule 81 (compexp -> sumexp .)
    RBRACKET        reduce using rule 81 (compexp -> sumexp .)
    RPAREN          reduce using rule 81 (compexp -> sumexp .)
    SEMICOLON       reduce using rule 81 (compexp -> sumexp .)
    TO              reduce using rule 81 (compexp -> sumexp .)
    COMMA           reduce using rule 81 (compexp -> sumexp .)
    GT              shift and go to state 87
    LT              shift and go to state 88
    GTE             shift and go to state 89
    LTE             shift and go to state 90
    NE              shift and go to state 91


state 63

    (82) compexp -> compexp1 . sumexp
    (88) sumexp -> . mulexp
    (89) sumexp -> . mulexp PLUS mulexp
    (90) sumexp -> . mulexp MINUS mulexp
    (91) mulexp -> . pexp
    (92) mulexp -> . pexp MUL pexp
    (93) mulexp -> . pexp DIV pexp
    (94) pexp -> . var1
    (95) pexp -> . CTEI
    (96) pexp -> . CTEF
    (97) pexp -> . CTEC
    (98) pexp -> . llamada
    (99) pexp -> . LPAREN exp RPAREN
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (61) llamada -> . ID LPAREN exp RPAREN
    (100) empty -> .

    CTEI            shift and go to state 93
    CTEF            shift and go to state 67
    CTEC            shift and go to state 68
    LPAREN          shift and go to state 70
    ID              shift and go to state 71
    MUL             reduce using rule 100 (empty -> .)
    DIV             reduce using rule 100 (empty -> .)
    PLUS            reduce using rule 100 (empty -> .)
    MINUS           reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    RBRACKET        reduce using rule 100 (empty -> .)
    RPAREN          reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    TO              reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)

    sumexp                         shift and go to state 92
    mulexp                         shift and go to state 64
    pexp                           shift and go to state 65
    var1                           shift and go to state 66
    llamada                        shift and go to state 69
    empty                          shift and go to state 44

state 64

    (88) sumexp -> mulexp .
    (89) sumexp -> mulexp . PLUS mulexp
    (90) sumexp -> mulexp . MINUS mulexp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    GT              reduce using rule 88 (sumexp -> mulexp .)
    LT              reduce using rule 88 (sumexp -> mulexp .)
    GTE             reduce using rule 88 (sumexp -> mulexp .)
    LTE             reduce using rule 88 (sumexp -> mulexp .)
    NE              reduce using rule 88 (sumexp -> mulexp .)
    AND             reduce using rule 88 (sumexp -> mulexp .)
    OR              reduce using rule 88 (sumexp -> mulexp .)
    RBRACKET        reduce using rule 88 (sumexp -> mulexp .)
    RPAREN          reduce using rule 88 (sumexp -> mulexp .)
    SEMICOLON       reduce using rule 88 (sumexp -> mulexp .)
    TO              reduce using rule 88 (sumexp -> mulexp .)
    COMMA           reduce using rule 88 (sumexp -> mulexp .)
    CTEI            reduce using rule 88 (sumexp -> mulexp .)
    CTEF            reduce using rule 88 (sumexp -> mulexp .)
    CTEC            reduce using rule 88 (sumexp -> mulexp .)
    LPAREN          reduce using rule 88 (sumexp -> mulexp .)
    ID              reduce using rule 88 (sumexp -> mulexp .)
    MUL             reduce using rule 88 (sumexp -> mulexp .)
    DIV             reduce using rule 88 (sumexp -> mulexp .)
    PLUS            shift and go to state 94
    MINUS           shift and go to state 95

  ! PLUS            [ reduce using rule 88 (sumexp -> mulexp .) ]
  ! MINUS           [ reduce using rule 88 (sumexp -> mulexp .) ]


state 65

    (91) mulexp -> pexp .
    (92) mulexp -> pexp . MUL pexp
    (93) mulexp -> pexp . DIV pexp

  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
    PLUS            reduce using rule 91 (mulexp -> pexp .)
    MINUS           reduce using rule 91 (mulexp -> pexp .)
    GT              reduce using rule 91 (mulexp -> pexp .)
    LT              reduce using rule 91 (mulexp -> pexp .)
    GTE             reduce using rule 91 (mulexp -> pexp .)
    LTE             reduce using rule 91 (mulexp -> pexp .)
    NE              reduce using rule 91 (mulexp -> pexp .)
    AND             reduce using rule 91 (mulexp -> pexp .)
    OR              reduce using rule 91 (mulexp -> pexp .)
    RBRACKET        reduce using rule 91 (mulexp -> pexp .)
    RPAREN          reduce using rule 91 (mulexp -> pexp .)
    SEMICOLON       reduce using rule 91 (mulexp -> pexp .)
    TO              reduce using rule 91 (mulexp -> pexp .)
    COMMA           reduce using rule 91 (mulexp -> pexp .)
    CTEI            reduce using rule 91 (mulexp -> pexp .)
    CTEF            reduce using rule 91 (mulexp -> pexp .)
    CTEC            reduce using rule 91 (mulexp -> pexp .)
    LPAREN          reduce using rule 91 (mulexp -> pexp .)
    ID              reduce using rule 91 (mulexp -> pexp .)
    MUL             shift and go to state 96
    DIV             shift and go to state 97

  ! MUL             [ reduce using rule 91 (mulexp -> pexp .) ]
  ! DIV             [ reduce using rule 91 (mulexp -> pexp .) ]


state 66

    (94) pexp -> var1 .

    MUL             reduce using rule 94 (pexp -> var1 .)
    DIV             reduce using rule 94 (pexp -> var1 .)
    PLUS            reduce using rule 94 (pexp -> var1 .)
    MINUS           reduce using rule 94 (pexp -> var1 .)
    GT              reduce using rule 94 (pexp -> var1 .)
    LT              reduce using rule 94 (pexp -> var1 .)
    GTE             reduce using rule 94 (pexp -> var1 .)
    LTE             reduce using rule 94 (pexp -> var1 .)
    NE              reduce using rule 94 (pexp -> var1 .)
    AND             reduce using rule 94 (pexp -> var1 .)
    OR              reduce using rule 94 (pexp -> var1 .)
    RBRACKET        reduce using rule 94 (pexp -> var1 .)
    RPAREN          reduce using rule 94 (pexp -> var1 .)
    SEMICOLON       reduce using rule 94 (pexp -> var1 .)
    TO              reduce using rule 94 (pexp -> var1 .)
    COMMA           reduce using rule 94 (pexp -> var1 .)
    CTEI            reduce using rule 94 (pexp -> var1 .)
    CTEF            reduce using rule 94 (pexp -> var1 .)
    CTEC            reduce using rule 94 (pexp -> var1 .)
    LPAREN          reduce using rule 94 (pexp -> var1 .)
    ID              reduce using rule 94 (pexp -> var1 .)


state 67

    (96) pexp -> CTEF .

    MUL             reduce using rule 96 (pexp -> CTEF .)
    DIV             reduce using rule 96 (pexp -> CTEF .)
    PLUS            reduce using rule 96 (pexp -> CTEF .)
    MINUS           reduce using rule 96 (pexp -> CTEF .)
    GT              reduce using rule 96 (pexp -> CTEF .)
    LT              reduce using rule 96 (pexp -> CTEF .)
    GTE             reduce using rule 96 (pexp -> CTEF .)
    LTE             reduce using rule 96 (pexp -> CTEF .)
    NE              reduce using rule 96 (pexp -> CTEF .)
    AND             reduce using rule 96 (pexp -> CTEF .)
    OR              reduce using rule 96 (pexp -> CTEF .)
    RBRACKET        reduce using rule 96 (pexp -> CTEF .)
    RPAREN          reduce using rule 96 (pexp -> CTEF .)
    SEMICOLON       reduce using rule 96 (pexp -> CTEF .)
    TO              reduce using rule 96 (pexp -> CTEF .)
    COMMA           reduce using rule 96 (pexp -> CTEF .)
    CTEI            reduce using rule 96 (pexp -> CTEF .)
    CTEF            reduce using rule 96 (pexp -> CTEF .)
    CTEC            reduce using rule 96 (pexp -> CTEF .)
    LPAREN          reduce using rule 96 (pexp -> CTEF .)
    ID              reduce using rule 96 (pexp -> CTEF .)


state 68

    (97) pexp -> CTEC .

    MUL             reduce using rule 97 (pexp -> CTEC .)
    DIV             reduce using rule 97 (pexp -> CTEC .)
    PLUS            reduce using rule 97 (pexp -> CTEC .)
    MINUS           reduce using rule 97 (pexp -> CTEC .)
    GT              reduce using rule 97 (pexp -> CTEC .)
    LT              reduce using rule 97 (pexp -> CTEC .)
    GTE             reduce using rule 97 (pexp -> CTEC .)
    LTE             reduce using rule 97 (pexp -> CTEC .)
    NE              reduce using rule 97 (pexp -> CTEC .)
    AND             reduce using rule 97 (pexp -> CTEC .)
    OR              reduce using rule 97 (pexp -> CTEC .)
    RBRACKET        reduce using rule 97 (pexp -> CTEC .)
    RPAREN          reduce using rule 97 (pexp -> CTEC .)
    SEMICOLON       reduce using rule 97 (pexp -> CTEC .)
    TO              reduce using rule 97 (pexp -> CTEC .)
    COMMA           reduce using rule 97 (pexp -> CTEC .)
    CTEI            reduce using rule 97 (pexp -> CTEC .)
    CTEF            reduce using rule 97 (pexp -> CTEC .)
    CTEC            reduce using rule 97 (pexp -> CTEC .)
    LPAREN          reduce using rule 97 (pexp -> CTEC .)
    ID              reduce using rule 97 (pexp -> CTEC .)


state 69

    (98) pexp -> llamada .

    MUL             reduce using rule 98 (pexp -> llamada .)
    DIV             reduce using rule 98 (pexp -> llamada .)
    PLUS            reduce using rule 98 (pexp -> llamada .)
    MINUS           reduce using rule 98 (pexp -> llamada .)
    GT              reduce using rule 98 (pexp -> llamada .)
    LT              reduce using rule 98 (pexp -> llamada .)
    GTE             reduce using rule 98 (pexp -> llamada .)
    LTE             reduce using rule 98 (pexp -> llamada .)
    NE              reduce using rule 98 (pexp -> llamada .)
    AND             reduce using rule 98 (pexp -> llamada .)
    OR              reduce using rule 98 (pexp -> llamada .)
    RBRACKET        reduce using rule 98 (pexp -> llamada .)
    RPAREN          reduce using rule 98 (pexp -> llamada .)
    SEMICOLON       reduce using rule 98 (pexp -> llamada .)
    TO              reduce using rule 98 (pexp -> llamada .)
    COMMA           reduce using rule 98 (pexp -> llamada .)
    CTEI            reduce using rule 98 (pexp -> llamada .)
    CTEF            reduce using rule 98 (pexp -> llamada .)
    CTEC            reduce using rule 98 (pexp -> llamada .)
    LPAREN          reduce using rule 98 (pexp -> llamada .)
    ID              reduce using rule 98 (pexp -> llamada .)


state 70

    (99) pexp -> LPAREN . exp RPAREN
    (77) exp -> . nexp
    (78) exp -> . nexp OR nexp
    (79) nexp -> . compexp
    (80) nexp -> . compexp AND compexp
    (81) compexp -> . sumexp
    (82) compexp -> . compexp1 sumexp
    (88) sumexp -> . mulexp
    (89) sumexp -> . mulexp PLUS mulexp
    (90) sumexp -> . mulexp MINUS mulexp
    (83) compexp1 -> . sumexp GT sumexp
    (84) compexp1 -> . sumexp LT sumexp
    (85) compexp1 -> . sumexp GTE sumexp
    (86) compexp1 -> . sumexp LTE sumexp
    (87) compexp1 -> . sumexp NE sumexp
    (91) mulexp -> . pexp
    (92) mulexp -> . pexp MUL pexp
    (93) mulexp -> . pexp DIV pexp
    (94) pexp -> . var1
    (95) pexp -> . CTEI
    (96) pexp -> . CTEF
    (97) pexp -> . CTEC
    (98) pexp -> . llamada
    (99) pexp -> . LPAREN exp RPAREN
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (61) llamada -> . ID LPAREN exp RPAREN
    (100) empty -> .

    CTEI            shift and go to state 93
    CTEF            shift and go to state 67
    CTEC            shift and go to state 68
    LPAREN          shift and go to state 70
    ID              shift and go to state 71
    MUL             reduce using rule 100 (empty -> .)
    DIV             reduce using rule 100 (empty -> .)
    PLUS            reduce using rule 100 (empty -> .)
    MINUS           reduce using rule 100 (empty -> .)
    GT              reduce using rule 100 (empty -> .)
    LT              reduce using rule 100 (empty -> .)
    GTE             reduce using rule 100 (empty -> .)
    LTE             reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    RPAREN          reduce using rule 100 (empty -> .)

    exp                            shift and go to state 98
    nexp                           shift and go to state 60
    compexp                        shift and go to state 61
    sumexp                         shift and go to state 62
    compexp1                       shift and go to state 63
    mulexp                         shift and go to state 64
    pexp                           shift and go to state 65
    var1                           shift and go to state 66
    llamada                        shift and go to state 69
    empty                          shift and go to state 44

state 71

    (14) var1 -> ID .
    (15) var1 -> ID . COMMA var1
    (16) var1 -> ID . arr
    (17) var1 -> ID . arr COMMA var1
    (18) var1 -> ID . mat COMMA var1
    (19) var1 -> ID . mat
    (20) var1 -> ID . mat especial
    (61) llamada -> ID . LPAREN exp RPAREN
    (29) arr -> . LBRACKET CTEI RBRACKET
    (30) arr -> . LBRACKET exp RBRACKET
    (31) mat -> . LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET
    (32) mat -> . LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (33) mat -> . LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET
    (34) mat -> . LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    MUL             reduce using rule 14 (var1 -> ID .)
    DIV             reduce using rule 14 (var1 -> ID .)
    PLUS            reduce using rule 14 (var1 -> ID .)
    MINUS           reduce using rule 14 (var1 -> ID .)
    GT              reduce using rule 14 (var1 -> ID .)
    LT              reduce using rule 14 (var1 -> ID .)
    GTE             reduce using rule 14 (var1 -> ID .)
    LTE             reduce using rule 14 (var1 -> ID .)
    NE              reduce using rule 14 (var1 -> ID .)
    AND             reduce using rule 14 (var1 -> ID .)
    OR              reduce using rule 14 (var1 -> ID .)
    RBRACKET        reduce using rule 14 (var1 -> ID .)
    RPAREN          reduce using rule 14 (var1 -> ID .)
    SEMICOLON       reduce using rule 14 (var1 -> ID .)
    TO              reduce using rule 14 (var1 -> ID .)
    CTEI            reduce using rule 14 (var1 -> ID .)
    CTEF            reduce using rule 14 (var1 -> ID .)
    CTEC            reduce using rule 14 (var1 -> ID .)
    ID              reduce using rule 14 (var1 -> ID .)
    COMMA           shift and go to state 55
    LPAREN          shift and go to state 99
    LBRACKET        shift and go to state 45

  ! COMMA           [ reduce using rule 14 (var1 -> ID .) ]
  ! LPAREN          [ reduce using rule 14 (var1 -> ID .) ]

    arr                            shift and go to state 56
    mat                            shift and go to state 57

state 72

    (7) main -> MAIN LPAREN param RPAREN LCURLY . vars statement RCURLY END
    (11) vars -> . var
    (12) vars -> . empty
    (13) var -> . VAR var2
    (100) empty -> .

    VAR             shift and go to state 12
    ID              reduce using rule 100 (empty -> .)
    READ            reduce using rule 100 (empty -> .)
    PRINT           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    RCURLY          reduce using rule 100 (empty -> .)

    vars                           shift and go to state 100
    var                            shift and go to state 9
    empty                          shift and go to state 10

state 73

    (59) param1 -> ID COMMA . param1
    (58) param1 -> . ID
    (59) param1 -> . ID COMMA param1
    (60) param1 -> . empty
    (100) empty -> .

    ID              shift and go to state 48
    RPAREN          reduce using rule 100 (empty -> .)

    param1                         shift and go to state 101
    empty                          shift and go to state 49

state 74

    (42) function1 -> ID save_fun LPAREN . param RPAREN SEMICOLON LCURLY vars statement RCURLY
    (56) param -> . tipo param1
    (57) param -> . empty
    (8) tipo -> . INT
    (9) tipo -> . FLOAT
    (10) tipo -> . CHAR
    (100) empty -> .

    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    CHAR            shift and go to state 30
    RPAREN          reduce using rule 100 (empty -> .)

    param                          shift and go to state 102
    tipo                           shift and go to state 32
    empty                          shift and go to state 33

state 75

    (43) function2 -> ID save_fun LPAREN . param RPAREN SEMICOLON LCURLY vars statement RETURN exp SEMICOLON RCURLY
    (56) param -> . tipo param1
    (57) param -> . empty
    (8) tipo -> . INT
    (9) tipo -> . FLOAT
    (10) tipo -> . CHAR
    (100) empty -> .

    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    CHAR            shift and go to state 30
    RPAREN          reduce using rule 100 (empty -> .)

    param                          shift and go to state 103
    tipo                           shift and go to state 32
    empty                          shift and go to state 33

state 76

    (15) var1 -> ID COMMA var1 .

    SEMICOLON       reduce using rule 15 (var1 -> ID COMMA var1 .)
    MUL             reduce using rule 15 (var1 -> ID COMMA var1 .)
    DIV             reduce using rule 15 (var1 -> ID COMMA var1 .)
    PLUS            reduce using rule 15 (var1 -> ID COMMA var1 .)
    MINUS           reduce using rule 15 (var1 -> ID COMMA var1 .)
    GT              reduce using rule 15 (var1 -> ID COMMA var1 .)
    LT              reduce using rule 15 (var1 -> ID COMMA var1 .)
    GTE             reduce using rule 15 (var1 -> ID COMMA var1 .)
    LTE             reduce using rule 15 (var1 -> ID COMMA var1 .)
    NE              reduce using rule 15 (var1 -> ID COMMA var1 .)
    AND             reduce using rule 15 (var1 -> ID COMMA var1 .)
    OR              reduce using rule 15 (var1 -> ID COMMA var1 .)
    RBRACKET        reduce using rule 15 (var1 -> ID COMMA var1 .)
    RPAREN          reduce using rule 15 (var1 -> ID COMMA var1 .)
    TO              reduce using rule 15 (var1 -> ID COMMA var1 .)
    COMMA           reduce using rule 15 (var1 -> ID COMMA var1 .)
    CTEI            reduce using rule 15 (var1 -> ID COMMA var1 .)
    CTEF            reduce using rule 15 (var1 -> ID COMMA var1 .)
    CTEC            reduce using rule 15 (var1 -> ID COMMA var1 .)
    LPAREN          reduce using rule 15 (var1 -> ID COMMA var1 .)
    ID              reduce using rule 15 (var1 -> ID COMMA var1 .)


state 77

    (17) var1 -> ID arr COMMA . var1
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (100) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 43
    SEMICOLON       reduce using rule 100 (empty -> .)
    MUL             reduce using rule 100 (empty -> .)
    DIV             reduce using rule 100 (empty -> .)
    PLUS            reduce using rule 100 (empty -> .)
    MINUS           reduce using rule 100 (empty -> .)
    GT              reduce using rule 100 (empty -> .)
    LT              reduce using rule 100 (empty -> .)
    GTE             reduce using rule 100 (empty -> .)
    LTE             reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    RBRACKET        reduce using rule 100 (empty -> .)
    RPAREN          reduce using rule 100 (empty -> .)
    TO              reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    CTEI            reduce using rule 100 (empty -> .)
    CTEF            reduce using rule 100 (empty -> .)
    CTEC            reduce using rule 100 (empty -> .)
    LPAREN          reduce using rule 100 (empty -> .)

  ! ID              [ reduce using rule 100 (empty -> .) ]

    var1                           shift and go to state 104
    empty                          shift and go to state 44

state 78

    (18) var1 -> ID mat COMMA . var1
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (100) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 43
    SEMICOLON       reduce using rule 100 (empty -> .)
    MUL             reduce using rule 100 (empty -> .)
    DIV             reduce using rule 100 (empty -> .)
    PLUS            reduce using rule 100 (empty -> .)
    MINUS           reduce using rule 100 (empty -> .)
    GT              reduce using rule 100 (empty -> .)
    LT              reduce using rule 100 (empty -> .)
    GTE             reduce using rule 100 (empty -> .)
    LTE             reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    RBRACKET        reduce using rule 100 (empty -> .)
    RPAREN          reduce using rule 100 (empty -> .)
    TO              reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    CTEI            reduce using rule 100 (empty -> .)
    CTEF            reduce using rule 100 (empty -> .)
    CTEC            reduce using rule 100 (empty -> .)
    LPAREN          reduce using rule 100 (empty -> .)

  ! ID              [ reduce using rule 100 (empty -> .) ]

    var1                           shift and go to state 105
    empty                          shift and go to state 44

state 79

    (20) var1 -> ID mat especial .

    SEMICOLON       reduce using rule 20 (var1 -> ID mat especial .)
    MUL             reduce using rule 20 (var1 -> ID mat especial .)
    DIV             reduce using rule 20 (var1 -> ID mat especial .)
    PLUS            reduce using rule 20 (var1 -> ID mat especial .)
    MINUS           reduce using rule 20 (var1 -> ID mat especial .)
    GT              reduce using rule 20 (var1 -> ID mat especial .)
    LT              reduce using rule 20 (var1 -> ID mat especial .)
    GTE             reduce using rule 20 (var1 -> ID mat especial .)
    LTE             reduce using rule 20 (var1 -> ID mat especial .)
    NE              reduce using rule 20 (var1 -> ID mat especial .)
    AND             reduce using rule 20 (var1 -> ID mat especial .)
    OR              reduce using rule 20 (var1 -> ID mat especial .)
    RBRACKET        reduce using rule 20 (var1 -> ID mat especial .)
    RPAREN          reduce using rule 20 (var1 -> ID mat especial .)
    TO              reduce using rule 20 (var1 -> ID mat especial .)
    COMMA           reduce using rule 20 (var1 -> ID mat especial .)
    CTEI            reduce using rule 20 (var1 -> ID mat especial .)
    CTEF            reduce using rule 20 (var1 -> ID mat especial .)
    CTEC            reduce using rule 20 (var1 -> ID mat especial .)
    LPAREN          reduce using rule 20 (var1 -> ID mat especial .)
    ID              reduce using rule 20 (var1 -> ID mat especial .)


state 80

    (26) especial -> TRANSPUESTA .

    SEMICOLON       reduce using rule 26 (especial -> TRANSPUESTA .)
    MUL             reduce using rule 26 (especial -> TRANSPUESTA .)
    DIV             reduce using rule 26 (especial -> TRANSPUESTA .)
    PLUS            reduce using rule 26 (especial -> TRANSPUESTA .)
    MINUS           reduce using rule 26 (especial -> TRANSPUESTA .)
    GT              reduce using rule 26 (especial -> TRANSPUESTA .)
    LT              reduce using rule 26 (especial -> TRANSPUESTA .)
    GTE             reduce using rule 26 (especial -> TRANSPUESTA .)
    LTE             reduce using rule 26 (especial -> TRANSPUESTA .)
    NE              reduce using rule 26 (especial -> TRANSPUESTA .)
    AND             reduce using rule 26 (especial -> TRANSPUESTA .)
    OR              reduce using rule 26 (especial -> TRANSPUESTA .)
    RBRACKET        reduce using rule 26 (especial -> TRANSPUESTA .)
    RPAREN          reduce using rule 26 (especial -> TRANSPUESTA .)
    TO              reduce using rule 26 (especial -> TRANSPUESTA .)
    COMMA           reduce using rule 26 (especial -> TRANSPUESTA .)
    CTEI            reduce using rule 26 (especial -> TRANSPUESTA .)
    CTEF            reduce using rule 26 (especial -> TRANSPUESTA .)
    CTEC            reduce using rule 26 (especial -> TRANSPUESTA .)
    LPAREN          reduce using rule 26 (especial -> TRANSPUESTA .)
    ID              reduce using rule 26 (especial -> TRANSPUESTA .)


state 81

    (27) especial -> INVERSA .

    SEMICOLON       reduce using rule 27 (especial -> INVERSA .)
    MUL             reduce using rule 27 (especial -> INVERSA .)
    DIV             reduce using rule 27 (especial -> INVERSA .)
    PLUS            reduce using rule 27 (especial -> INVERSA .)
    MINUS           reduce using rule 27 (especial -> INVERSA .)
    GT              reduce using rule 27 (especial -> INVERSA .)
    LT              reduce using rule 27 (especial -> INVERSA .)
    GTE             reduce using rule 27 (especial -> INVERSA .)
    LTE             reduce using rule 27 (especial -> INVERSA .)
    NE              reduce using rule 27 (especial -> INVERSA .)
    AND             reduce using rule 27 (especial -> INVERSA .)
    OR              reduce using rule 27 (especial -> INVERSA .)
    RBRACKET        reduce using rule 27 (especial -> INVERSA .)
    RPAREN          reduce using rule 27 (especial -> INVERSA .)
    TO              reduce using rule 27 (especial -> INVERSA .)
    COMMA           reduce using rule 27 (especial -> INVERSA .)
    CTEI            reduce using rule 27 (especial -> INVERSA .)
    CTEF            reduce using rule 27 (especial -> INVERSA .)
    CTEC            reduce using rule 27 (especial -> INVERSA .)
    LPAREN          reduce using rule 27 (especial -> INVERSA .)
    ID              reduce using rule 27 (especial -> INVERSA .)


state 82

    (28) especial -> DETERMINANTE .

    SEMICOLON       reduce using rule 28 (especial -> DETERMINANTE .)
    MUL             reduce using rule 28 (especial -> DETERMINANTE .)
    DIV             reduce using rule 28 (especial -> DETERMINANTE .)
    PLUS            reduce using rule 28 (especial -> DETERMINANTE .)
    MINUS           reduce using rule 28 (especial -> DETERMINANTE .)
    GT              reduce using rule 28 (especial -> DETERMINANTE .)
    LT              reduce using rule 28 (especial -> DETERMINANTE .)
    GTE             reduce using rule 28 (especial -> DETERMINANTE .)
    LTE             reduce using rule 28 (especial -> DETERMINANTE .)
    NE              reduce using rule 28 (especial -> DETERMINANTE .)
    AND             reduce using rule 28 (especial -> DETERMINANTE .)
    OR              reduce using rule 28 (especial -> DETERMINANTE .)
    RBRACKET        reduce using rule 28 (especial -> DETERMINANTE .)
    RPAREN          reduce using rule 28 (especial -> DETERMINANTE .)
    TO              reduce using rule 28 (especial -> DETERMINANTE .)
    COMMA           reduce using rule 28 (especial -> DETERMINANTE .)
    CTEI            reduce using rule 28 (especial -> DETERMINANTE .)
    CTEF            reduce using rule 28 (especial -> DETERMINANTE .)
    CTEC            reduce using rule 28 (especial -> DETERMINANTE .)
    LPAREN          reduce using rule 28 (especial -> DETERMINANTE .)
    ID              reduce using rule 28 (especial -> DETERMINANTE .)


state 83

    (29) arr -> LBRACKET CTEI RBRACKET .
    (31) mat -> LBRACKET CTEI RBRACKET . LBRACKET CTEI RBRACKET
    (34) mat -> LBRACKET CTEI RBRACKET . LBRACKET exp RBRACKET

    SEMICOLON       reduce using rule 29 (arr -> LBRACKET CTEI RBRACKET .)
    COMMA           reduce using rule 29 (arr -> LBRACKET CTEI RBRACKET .)
    MUL             reduce using rule 29 (arr -> LBRACKET CTEI RBRACKET .)
    DIV             reduce using rule 29 (arr -> LBRACKET CTEI RBRACKET .)
    PLUS            reduce using rule 29 (arr -> LBRACKET CTEI RBRACKET .)
    MINUS           reduce using rule 29 (arr -> LBRACKET CTEI RBRACKET .)
    GT              reduce using rule 29 (arr -> LBRACKET CTEI RBRACKET .)
    LT              reduce using rule 29 (arr -> LBRACKET CTEI RBRACKET .)
    GTE             reduce using rule 29 (arr -> LBRACKET CTEI RBRACKET .)
    LTE             reduce using rule 29 (arr -> LBRACKET CTEI RBRACKET .)
    NE              reduce using rule 29 (arr -> LBRACKET CTEI RBRACKET .)
    AND             reduce using rule 29 (arr -> LBRACKET CTEI RBRACKET .)
    OR              reduce using rule 29 (arr -> LBRACKET CTEI RBRACKET .)
    RBRACKET        reduce using rule 29 (arr -> LBRACKET CTEI RBRACKET .)
    RPAREN          reduce using rule 29 (arr -> LBRACKET CTEI RBRACKET .)
    TO              reduce using rule 29 (arr -> LBRACKET CTEI RBRACKET .)
    CTEI            reduce using rule 29 (arr -> LBRACKET CTEI RBRACKET .)
    CTEF            reduce using rule 29 (arr -> LBRACKET CTEI RBRACKET .)
    CTEC            reduce using rule 29 (arr -> LBRACKET CTEI RBRACKET .)
    LPAREN          reduce using rule 29 (arr -> LBRACKET CTEI RBRACKET .)
    ID              reduce using rule 29 (arr -> LBRACKET CTEI RBRACKET .)
    EQUALS          reduce using rule 29 (arr -> LBRACKET CTEI RBRACKET .)
    LBRACKET        shift and go to state 106


state 84

    (30) arr -> LBRACKET exp RBRACKET .
    (32) mat -> LBRACKET exp RBRACKET . LBRACKET exp RBRACKET
    (33) mat -> LBRACKET exp RBRACKET . LBRACKET CTEI RBRACKET

    SEMICOLON       reduce using rule 30 (arr -> LBRACKET exp RBRACKET .)
    COMMA           reduce using rule 30 (arr -> LBRACKET exp RBRACKET .)
    MUL             reduce using rule 30 (arr -> LBRACKET exp RBRACKET .)
    DIV             reduce using rule 30 (arr -> LBRACKET exp RBRACKET .)
    PLUS            reduce using rule 30 (arr -> LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 30 (arr -> LBRACKET exp RBRACKET .)
    GT              reduce using rule 30 (arr -> LBRACKET exp RBRACKET .)
    LT              reduce using rule 30 (arr -> LBRACKET exp RBRACKET .)
    GTE             reduce using rule 30 (arr -> LBRACKET exp RBRACKET .)
    LTE             reduce using rule 30 (arr -> LBRACKET exp RBRACKET .)
    NE              reduce using rule 30 (arr -> LBRACKET exp RBRACKET .)
    AND             reduce using rule 30 (arr -> LBRACKET exp RBRACKET .)
    OR              reduce using rule 30 (arr -> LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 30 (arr -> LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 30 (arr -> LBRACKET exp RBRACKET .)
    TO              reduce using rule 30 (arr -> LBRACKET exp RBRACKET .)
    CTEI            reduce using rule 30 (arr -> LBRACKET exp RBRACKET .)
    CTEF            reduce using rule 30 (arr -> LBRACKET exp RBRACKET .)
    CTEC            reduce using rule 30 (arr -> LBRACKET exp RBRACKET .)
    LPAREN          reduce using rule 30 (arr -> LBRACKET exp RBRACKET .)
    ID              reduce using rule 30 (arr -> LBRACKET exp RBRACKET .)
    EQUALS          reduce using rule 30 (arr -> LBRACKET exp RBRACKET .)
    LBRACKET        shift and go to state 107


state 85

    (78) exp -> nexp OR . nexp
    (79) nexp -> . compexp
    (80) nexp -> . compexp AND compexp
    (81) compexp -> . sumexp
    (82) compexp -> . compexp1 sumexp
    (88) sumexp -> . mulexp
    (89) sumexp -> . mulexp PLUS mulexp
    (90) sumexp -> . mulexp MINUS mulexp
    (83) compexp1 -> . sumexp GT sumexp
    (84) compexp1 -> . sumexp LT sumexp
    (85) compexp1 -> . sumexp GTE sumexp
    (86) compexp1 -> . sumexp LTE sumexp
    (87) compexp1 -> . sumexp NE sumexp
    (91) mulexp -> . pexp
    (92) mulexp -> . pexp MUL pexp
    (93) mulexp -> . pexp DIV pexp
    (94) pexp -> . var1
    (95) pexp -> . CTEI
    (96) pexp -> . CTEF
    (97) pexp -> . CTEC
    (98) pexp -> . llamada
    (99) pexp -> . LPAREN exp RPAREN
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (61) llamada -> . ID LPAREN exp RPAREN
    (100) empty -> .

    CTEI            shift and go to state 93
    CTEF            shift and go to state 67
    CTEC            shift and go to state 68
    LPAREN          shift and go to state 70
    ID              shift and go to state 71
    MUL             reduce using rule 100 (empty -> .)
    DIV             reduce using rule 100 (empty -> .)
    PLUS            reduce using rule 100 (empty -> .)
    MINUS           reduce using rule 100 (empty -> .)
    GT              reduce using rule 100 (empty -> .)
    LT              reduce using rule 100 (empty -> .)
    GTE             reduce using rule 100 (empty -> .)
    LTE             reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    RBRACKET        reduce using rule 100 (empty -> .)
    RPAREN          reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    TO              reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)

    nexp                           shift and go to state 108
    compexp                        shift and go to state 61
    sumexp                         shift and go to state 62
    compexp1                       shift and go to state 63
    mulexp                         shift and go to state 64
    pexp                           shift and go to state 65
    var1                           shift and go to state 66
    llamada                        shift and go to state 69
    empty                          shift and go to state 44

state 86

    (80) nexp -> compexp AND . compexp
    (81) compexp -> . sumexp
    (82) compexp -> . compexp1 sumexp
    (88) sumexp -> . mulexp
    (89) sumexp -> . mulexp PLUS mulexp
    (90) sumexp -> . mulexp MINUS mulexp
    (83) compexp1 -> . sumexp GT sumexp
    (84) compexp1 -> . sumexp LT sumexp
    (85) compexp1 -> . sumexp GTE sumexp
    (86) compexp1 -> . sumexp LTE sumexp
    (87) compexp1 -> . sumexp NE sumexp
    (91) mulexp -> . pexp
    (92) mulexp -> . pexp MUL pexp
    (93) mulexp -> . pexp DIV pexp
    (94) pexp -> . var1
    (95) pexp -> . CTEI
    (96) pexp -> . CTEF
    (97) pexp -> . CTEC
    (98) pexp -> . llamada
    (99) pexp -> . LPAREN exp RPAREN
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (61) llamada -> . ID LPAREN exp RPAREN
    (100) empty -> .

    CTEI            shift and go to state 93
    CTEF            shift and go to state 67
    CTEC            shift and go to state 68
    LPAREN          shift and go to state 70
    ID              shift and go to state 71
    MUL             reduce using rule 100 (empty -> .)
    DIV             reduce using rule 100 (empty -> .)
    PLUS            reduce using rule 100 (empty -> .)
    MINUS           reduce using rule 100 (empty -> .)
    GT              reduce using rule 100 (empty -> .)
    LT              reduce using rule 100 (empty -> .)
    GTE             reduce using rule 100 (empty -> .)
    LTE             reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    RBRACKET        reduce using rule 100 (empty -> .)
    RPAREN          reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    TO              reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)

    compexp                        shift and go to state 109
    sumexp                         shift and go to state 62
    compexp1                       shift and go to state 63
    mulexp                         shift and go to state 64
    pexp                           shift and go to state 65
    var1                           shift and go to state 66
    llamada                        shift and go to state 69
    empty                          shift and go to state 44

state 87

    (83) compexp1 -> sumexp GT . sumexp
    (88) sumexp -> . mulexp
    (89) sumexp -> . mulexp PLUS mulexp
    (90) sumexp -> . mulexp MINUS mulexp
    (91) mulexp -> . pexp
    (92) mulexp -> . pexp MUL pexp
    (93) mulexp -> . pexp DIV pexp
    (94) pexp -> . var1
    (95) pexp -> . CTEI
    (96) pexp -> . CTEF
    (97) pexp -> . CTEC
    (98) pexp -> . llamada
    (99) pexp -> . LPAREN exp RPAREN
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (61) llamada -> . ID LPAREN exp RPAREN
    (100) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 93
    CTEF            shift and go to state 67
    CTEC            shift and go to state 68
    LPAREN          shift and go to state 70
    ID              shift and go to state 71
    MUL             reduce using rule 100 (empty -> .)
    DIV             reduce using rule 100 (empty -> .)
    PLUS            reduce using rule 100 (empty -> .)
    MINUS           reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    RBRACKET        reduce using rule 100 (empty -> .)
    RPAREN          reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    TO              reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)

  ! CTEI            [ reduce using rule 100 (empty -> .) ]
  ! CTEF            [ reduce using rule 100 (empty -> .) ]
  ! CTEC            [ reduce using rule 100 (empty -> .) ]
  ! LPAREN          [ reduce using rule 100 (empty -> .) ]
  ! ID              [ reduce using rule 100 (empty -> .) ]

    sumexp                         shift and go to state 110
    mulexp                         shift and go to state 64
    pexp                           shift and go to state 65
    var1                           shift and go to state 66
    llamada                        shift and go to state 69
    empty                          shift and go to state 44

state 88

    (84) compexp1 -> sumexp LT . sumexp
    (88) sumexp -> . mulexp
    (89) sumexp -> . mulexp PLUS mulexp
    (90) sumexp -> . mulexp MINUS mulexp
    (91) mulexp -> . pexp
    (92) mulexp -> . pexp MUL pexp
    (93) mulexp -> . pexp DIV pexp
    (94) pexp -> . var1
    (95) pexp -> . CTEI
    (96) pexp -> . CTEF
    (97) pexp -> . CTEC
    (98) pexp -> . llamada
    (99) pexp -> . LPAREN exp RPAREN
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (61) llamada -> . ID LPAREN exp RPAREN
    (100) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 93
    CTEF            shift and go to state 67
    CTEC            shift and go to state 68
    LPAREN          shift and go to state 70
    ID              shift and go to state 71
    MUL             reduce using rule 100 (empty -> .)
    DIV             reduce using rule 100 (empty -> .)
    PLUS            reduce using rule 100 (empty -> .)
    MINUS           reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    RBRACKET        reduce using rule 100 (empty -> .)
    RPAREN          reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    TO              reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)

  ! CTEI            [ reduce using rule 100 (empty -> .) ]
  ! CTEF            [ reduce using rule 100 (empty -> .) ]
  ! CTEC            [ reduce using rule 100 (empty -> .) ]
  ! LPAREN          [ reduce using rule 100 (empty -> .) ]
  ! ID              [ reduce using rule 100 (empty -> .) ]

    sumexp                         shift and go to state 111
    mulexp                         shift and go to state 64
    pexp                           shift and go to state 65
    var1                           shift and go to state 66
    llamada                        shift and go to state 69
    empty                          shift and go to state 44

state 89

    (85) compexp1 -> sumexp GTE . sumexp
    (88) sumexp -> . mulexp
    (89) sumexp -> . mulexp PLUS mulexp
    (90) sumexp -> . mulexp MINUS mulexp
    (91) mulexp -> . pexp
    (92) mulexp -> . pexp MUL pexp
    (93) mulexp -> . pexp DIV pexp
    (94) pexp -> . var1
    (95) pexp -> . CTEI
    (96) pexp -> . CTEF
    (97) pexp -> . CTEC
    (98) pexp -> . llamada
    (99) pexp -> . LPAREN exp RPAREN
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (61) llamada -> . ID LPAREN exp RPAREN
    (100) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 93
    CTEF            shift and go to state 67
    CTEC            shift and go to state 68
    LPAREN          shift and go to state 70
    ID              shift and go to state 71
    MUL             reduce using rule 100 (empty -> .)
    DIV             reduce using rule 100 (empty -> .)
    PLUS            reduce using rule 100 (empty -> .)
    MINUS           reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    RBRACKET        reduce using rule 100 (empty -> .)
    RPAREN          reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    TO              reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)

  ! CTEI            [ reduce using rule 100 (empty -> .) ]
  ! CTEF            [ reduce using rule 100 (empty -> .) ]
  ! CTEC            [ reduce using rule 100 (empty -> .) ]
  ! LPAREN          [ reduce using rule 100 (empty -> .) ]
  ! ID              [ reduce using rule 100 (empty -> .) ]

    sumexp                         shift and go to state 112
    mulexp                         shift and go to state 64
    pexp                           shift and go to state 65
    var1                           shift and go to state 66
    llamada                        shift and go to state 69
    empty                          shift and go to state 44

state 90

    (86) compexp1 -> sumexp LTE . sumexp
    (88) sumexp -> . mulexp
    (89) sumexp -> . mulexp PLUS mulexp
    (90) sumexp -> . mulexp MINUS mulexp
    (91) mulexp -> . pexp
    (92) mulexp -> . pexp MUL pexp
    (93) mulexp -> . pexp DIV pexp
    (94) pexp -> . var1
    (95) pexp -> . CTEI
    (96) pexp -> . CTEF
    (97) pexp -> . CTEC
    (98) pexp -> . llamada
    (99) pexp -> . LPAREN exp RPAREN
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (61) llamada -> . ID LPAREN exp RPAREN
    (100) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 93
    CTEF            shift and go to state 67
    CTEC            shift and go to state 68
    LPAREN          shift and go to state 70
    ID              shift and go to state 71
    MUL             reduce using rule 100 (empty -> .)
    DIV             reduce using rule 100 (empty -> .)
    PLUS            reduce using rule 100 (empty -> .)
    MINUS           reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    RBRACKET        reduce using rule 100 (empty -> .)
    RPAREN          reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    TO              reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)

  ! CTEI            [ reduce using rule 100 (empty -> .) ]
  ! CTEF            [ reduce using rule 100 (empty -> .) ]
  ! CTEC            [ reduce using rule 100 (empty -> .) ]
  ! LPAREN          [ reduce using rule 100 (empty -> .) ]
  ! ID              [ reduce using rule 100 (empty -> .) ]

    sumexp                         shift and go to state 113
    mulexp                         shift and go to state 64
    pexp                           shift and go to state 65
    var1                           shift and go to state 66
    llamada                        shift and go to state 69
    empty                          shift and go to state 44

state 91

    (87) compexp1 -> sumexp NE . sumexp
    (88) sumexp -> . mulexp
    (89) sumexp -> . mulexp PLUS mulexp
    (90) sumexp -> . mulexp MINUS mulexp
    (91) mulexp -> . pexp
    (92) mulexp -> . pexp MUL pexp
    (93) mulexp -> . pexp DIV pexp
    (94) pexp -> . var1
    (95) pexp -> . CTEI
    (96) pexp -> . CTEF
    (97) pexp -> . CTEC
    (98) pexp -> . llamada
    (99) pexp -> . LPAREN exp RPAREN
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (61) llamada -> . ID LPAREN exp RPAREN
    (100) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 93
    CTEF            shift and go to state 67
    CTEC            shift and go to state 68
    LPAREN          shift and go to state 70
    ID              shift and go to state 71
    MUL             reduce using rule 100 (empty -> .)
    DIV             reduce using rule 100 (empty -> .)
    PLUS            reduce using rule 100 (empty -> .)
    MINUS           reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    RBRACKET        reduce using rule 100 (empty -> .)
    RPAREN          reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    TO              reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)

  ! CTEI            [ reduce using rule 100 (empty -> .) ]
  ! CTEF            [ reduce using rule 100 (empty -> .) ]
  ! CTEC            [ reduce using rule 100 (empty -> .) ]
  ! LPAREN          [ reduce using rule 100 (empty -> .) ]
  ! ID              [ reduce using rule 100 (empty -> .) ]

    sumexp                         shift and go to state 114
    mulexp                         shift and go to state 64
    pexp                           shift and go to state 65
    var1                           shift and go to state 66
    llamada                        shift and go to state 69
    empty                          shift and go to state 44

state 92

    (82) compexp -> compexp1 sumexp .

    AND             reduce using rule 82 (compexp -> compexp1 sumexp .)
    OR              reduce using rule 82 (compexp -> compexp1 sumexp .)
    RBRACKET        reduce using rule 82 (compexp -> compexp1 sumexp .)
    RPAREN          reduce using rule 82 (compexp -> compexp1 sumexp .)
    SEMICOLON       reduce using rule 82 (compexp -> compexp1 sumexp .)
    TO              reduce using rule 82 (compexp -> compexp1 sumexp .)
    COMMA           reduce using rule 82 (compexp -> compexp1 sumexp .)


state 93

    (95) pexp -> CTEI .

    MUL             reduce using rule 95 (pexp -> CTEI .)
    DIV             reduce using rule 95 (pexp -> CTEI .)
    PLUS            reduce using rule 95 (pexp -> CTEI .)
    MINUS           reduce using rule 95 (pexp -> CTEI .)
    AND             reduce using rule 95 (pexp -> CTEI .)
    OR              reduce using rule 95 (pexp -> CTEI .)
    RBRACKET        reduce using rule 95 (pexp -> CTEI .)
    RPAREN          reduce using rule 95 (pexp -> CTEI .)
    SEMICOLON       reduce using rule 95 (pexp -> CTEI .)
    TO              reduce using rule 95 (pexp -> CTEI .)
    COMMA           reduce using rule 95 (pexp -> CTEI .)
    GT              reduce using rule 95 (pexp -> CTEI .)
    LT              reduce using rule 95 (pexp -> CTEI .)
    GTE             reduce using rule 95 (pexp -> CTEI .)
    LTE             reduce using rule 95 (pexp -> CTEI .)
    NE              reduce using rule 95 (pexp -> CTEI .)
    CTEI            reduce using rule 95 (pexp -> CTEI .)
    CTEF            reduce using rule 95 (pexp -> CTEI .)
    CTEC            reduce using rule 95 (pexp -> CTEI .)
    LPAREN          reduce using rule 95 (pexp -> CTEI .)
    ID              reduce using rule 95 (pexp -> CTEI .)


state 94

    (89) sumexp -> mulexp PLUS . mulexp
    (91) mulexp -> . pexp
    (92) mulexp -> . pexp MUL pexp
    (93) mulexp -> . pexp DIV pexp
    (94) pexp -> . var1
    (95) pexp -> . CTEI
    (96) pexp -> . CTEF
    (97) pexp -> . CTEC
    (98) pexp -> . llamada
    (99) pexp -> . LPAREN exp RPAREN
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (61) llamada -> . ID LPAREN exp RPAREN
    (100) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 93
    CTEF            shift and go to state 67
    CTEC            shift and go to state 68
    LPAREN          shift and go to state 70
    ID              shift and go to state 71
    MUL             reduce using rule 100 (empty -> .)
    DIV             reduce using rule 100 (empty -> .)
    GT              reduce using rule 100 (empty -> .)
    LT              reduce using rule 100 (empty -> .)
    GTE             reduce using rule 100 (empty -> .)
    LTE             reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    RBRACKET        reduce using rule 100 (empty -> .)
    RPAREN          reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    TO              reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    PLUS            reduce using rule 100 (empty -> .)
    MINUS           reduce using rule 100 (empty -> .)

  ! CTEI            [ reduce using rule 100 (empty -> .) ]
  ! CTEF            [ reduce using rule 100 (empty -> .) ]
  ! CTEC            [ reduce using rule 100 (empty -> .) ]
  ! LPAREN          [ reduce using rule 100 (empty -> .) ]
  ! ID              [ reduce using rule 100 (empty -> .) ]

    mulexp                         shift and go to state 115
    pexp                           shift and go to state 65
    var1                           shift and go to state 66
    llamada                        shift and go to state 69
    empty                          shift and go to state 44

state 95

    (90) sumexp -> mulexp MINUS . mulexp
    (91) mulexp -> . pexp
    (92) mulexp -> . pexp MUL pexp
    (93) mulexp -> . pexp DIV pexp
    (94) pexp -> . var1
    (95) pexp -> . CTEI
    (96) pexp -> . CTEF
    (97) pexp -> . CTEC
    (98) pexp -> . llamada
    (99) pexp -> . LPAREN exp RPAREN
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (61) llamada -> . ID LPAREN exp RPAREN
    (100) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 93
    CTEF            shift and go to state 67
    CTEC            shift and go to state 68
    LPAREN          shift and go to state 70
    ID              shift and go to state 71
    MUL             reduce using rule 100 (empty -> .)
    DIV             reduce using rule 100 (empty -> .)
    GT              reduce using rule 100 (empty -> .)
    LT              reduce using rule 100 (empty -> .)
    GTE             reduce using rule 100 (empty -> .)
    LTE             reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    RBRACKET        reduce using rule 100 (empty -> .)
    RPAREN          reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    TO              reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    PLUS            reduce using rule 100 (empty -> .)
    MINUS           reduce using rule 100 (empty -> .)

  ! CTEI            [ reduce using rule 100 (empty -> .) ]
  ! CTEF            [ reduce using rule 100 (empty -> .) ]
  ! CTEC            [ reduce using rule 100 (empty -> .) ]
  ! LPAREN          [ reduce using rule 100 (empty -> .) ]
  ! ID              [ reduce using rule 100 (empty -> .) ]

    mulexp                         shift and go to state 116
    pexp                           shift and go to state 65
    var1                           shift and go to state 66
    llamada                        shift and go to state 69
    empty                          shift and go to state 44

state 96

    (92) mulexp -> pexp MUL . pexp
    (94) pexp -> . var1
    (95) pexp -> . CTEI
    (96) pexp -> . CTEF
    (97) pexp -> . CTEC
    (98) pexp -> . llamada
    (99) pexp -> . LPAREN exp RPAREN
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (61) llamada -> . ID LPAREN exp RPAREN
    (100) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 93
    CTEF            shift and go to state 67
    CTEC            shift and go to state 68
    LPAREN          shift and go to state 70
    ID              shift and go to state 71
    PLUS            reduce using rule 100 (empty -> .)
    MINUS           reduce using rule 100 (empty -> .)
    GT              reduce using rule 100 (empty -> .)
    LT              reduce using rule 100 (empty -> .)
    GTE             reduce using rule 100 (empty -> .)
    LTE             reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    RBRACKET        reduce using rule 100 (empty -> .)
    RPAREN          reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    TO              reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    MUL             reduce using rule 100 (empty -> .)
    DIV             reduce using rule 100 (empty -> .)

  ! CTEI            [ reduce using rule 100 (empty -> .) ]
  ! CTEF            [ reduce using rule 100 (empty -> .) ]
  ! CTEC            [ reduce using rule 100 (empty -> .) ]
  ! LPAREN          [ reduce using rule 100 (empty -> .) ]
  ! ID              [ reduce using rule 100 (empty -> .) ]

    pexp                           shift and go to state 117
    var1                           shift and go to state 66
    llamada                        shift and go to state 69
    empty                          shift and go to state 44

state 97

    (93) mulexp -> pexp DIV . pexp
    (94) pexp -> . var1
    (95) pexp -> . CTEI
    (96) pexp -> . CTEF
    (97) pexp -> . CTEC
    (98) pexp -> . llamada
    (99) pexp -> . LPAREN exp RPAREN
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (61) llamada -> . ID LPAREN exp RPAREN
    (100) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 93
    CTEF            shift and go to state 67
    CTEC            shift and go to state 68
    LPAREN          shift and go to state 70
    ID              shift and go to state 71
    PLUS            reduce using rule 100 (empty -> .)
    MINUS           reduce using rule 100 (empty -> .)
    GT              reduce using rule 100 (empty -> .)
    LT              reduce using rule 100 (empty -> .)
    GTE             reduce using rule 100 (empty -> .)
    LTE             reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    RBRACKET        reduce using rule 100 (empty -> .)
    RPAREN          reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    TO              reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    MUL             reduce using rule 100 (empty -> .)
    DIV             reduce using rule 100 (empty -> .)

  ! CTEI            [ reduce using rule 100 (empty -> .) ]
  ! CTEF            [ reduce using rule 100 (empty -> .) ]
  ! CTEC            [ reduce using rule 100 (empty -> .) ]
  ! LPAREN          [ reduce using rule 100 (empty -> .) ]
  ! ID              [ reduce using rule 100 (empty -> .) ]

    pexp                           shift and go to state 118
    var1                           shift and go to state 66
    llamada                        shift and go to state 69
    empty                          shift and go to state 44

state 98

    (99) pexp -> LPAREN exp . RPAREN

    RPAREN          shift and go to state 119


state 99

    (61) llamada -> ID LPAREN . exp RPAREN
    (77) exp -> . nexp
    (78) exp -> . nexp OR nexp
    (79) nexp -> . compexp
    (80) nexp -> . compexp AND compexp
    (81) compexp -> . sumexp
    (82) compexp -> . compexp1 sumexp
    (88) sumexp -> . mulexp
    (89) sumexp -> . mulexp PLUS mulexp
    (90) sumexp -> . mulexp MINUS mulexp
    (83) compexp1 -> . sumexp GT sumexp
    (84) compexp1 -> . sumexp LT sumexp
    (85) compexp1 -> . sumexp GTE sumexp
    (86) compexp1 -> . sumexp LTE sumexp
    (87) compexp1 -> . sumexp NE sumexp
    (91) mulexp -> . pexp
    (92) mulexp -> . pexp MUL pexp
    (93) mulexp -> . pexp DIV pexp
    (94) pexp -> . var1
    (95) pexp -> . CTEI
    (96) pexp -> . CTEF
    (97) pexp -> . CTEC
    (98) pexp -> . llamada
    (99) pexp -> . LPAREN exp RPAREN
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (61) llamada -> . ID LPAREN exp RPAREN
    (100) empty -> .

    CTEI            shift and go to state 93
    CTEF            shift and go to state 67
    CTEC            shift and go to state 68
    LPAREN          shift and go to state 70
    ID              shift and go to state 71
    MUL             reduce using rule 100 (empty -> .)
    DIV             reduce using rule 100 (empty -> .)
    PLUS            reduce using rule 100 (empty -> .)
    MINUS           reduce using rule 100 (empty -> .)
    GT              reduce using rule 100 (empty -> .)
    LT              reduce using rule 100 (empty -> .)
    GTE             reduce using rule 100 (empty -> .)
    LTE             reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    RPAREN          reduce using rule 100 (empty -> .)

    exp                            shift and go to state 120
    nexp                           shift and go to state 60
    compexp                        shift and go to state 61
    sumexp                         shift and go to state 62
    compexp1                       shift and go to state 63
    mulexp                         shift and go to state 64
    pexp                           shift and go to state 65
    var1                           shift and go to state 66
    llamada                        shift and go to state 69
    empty                          shift and go to state 44

state 100

    (7) main -> MAIN LPAREN param RPAREN LCURLY vars . statement RCURLY END
    (44) statement -> . statement1 statement
    (45) statement -> . empty
    (46) statement1 -> . asignacion SEMICOLON
    (47) statement1 -> . llamada SEMICOLON
    (48) statement1 -> . lectura SEMICOLON
    (49) statement1 -> . escritura SEMICOLON
    (50) statement1 -> . for
    (51) statement1 -> . if
    (52) statement1 -> . while
    (100) empty -> .
    (53) asignacion -> . ID EQUALS exp
    (54) asignacion -> . ID arr EQUALS exp
    (55) asignacion -> . ID mat EQUALS exp
    (61) llamada -> . ID LPAREN exp RPAREN
    (76) lectura -> . READ LPAREN var1 RPAREN
    (69) escritura -> . PRINT LPAREN escritura1 RPAREN
    (66) for -> . FOR LPAREN for1 RPAREN LCURLY statement RCURLY
    (62) if -> . IF LPAREN exp RPAREN LCURLY statement RCURLY
    (63) if -> . IF LPAREN exp RPAREN LCURLY statement RCURLY else
    (68) while -> . WHILE LPAREN exp RPAREN LCURLY statement RCURLY

    RCURLY          reduce using rule 100 (empty -> .)
    ID              shift and go to state 131
    READ            shift and go to state 132
    PRINT           shift and go to state 133
    FOR             shift and go to state 134
    IF              shift and go to state 135
    WHILE           shift and go to state 136

    statement                      shift and go to state 121
    statement1                     shift and go to state 122
    empty                          shift and go to state 123
    asignacion                     shift and go to state 124
    llamada                        shift and go to state 125
    lectura                        shift and go to state 126
    escritura                      shift and go to state 127
    for                            shift and go to state 128
    if                             shift and go to state 129
    while                          shift and go to state 130

state 101

    (59) param1 -> ID COMMA param1 .

    RPAREN          reduce using rule 59 (param1 -> ID COMMA param1 .)


state 102

    (42) function1 -> ID save_fun LPAREN param . RPAREN SEMICOLON LCURLY vars statement RCURLY

    RPAREN          shift and go to state 137


state 103

    (43) function2 -> ID save_fun LPAREN param . RPAREN SEMICOLON LCURLY vars statement RETURN exp SEMICOLON RCURLY

    RPAREN          shift and go to state 138


state 104

    (17) var1 -> ID arr COMMA var1 .

    SEMICOLON       reduce using rule 17 (var1 -> ID arr COMMA var1 .)
    MUL             reduce using rule 17 (var1 -> ID arr COMMA var1 .)
    DIV             reduce using rule 17 (var1 -> ID arr COMMA var1 .)
    PLUS            reduce using rule 17 (var1 -> ID arr COMMA var1 .)
    MINUS           reduce using rule 17 (var1 -> ID arr COMMA var1 .)
    GT              reduce using rule 17 (var1 -> ID arr COMMA var1 .)
    LT              reduce using rule 17 (var1 -> ID arr COMMA var1 .)
    GTE             reduce using rule 17 (var1 -> ID arr COMMA var1 .)
    LTE             reduce using rule 17 (var1 -> ID arr COMMA var1 .)
    NE              reduce using rule 17 (var1 -> ID arr COMMA var1 .)
    AND             reduce using rule 17 (var1 -> ID arr COMMA var1 .)
    OR              reduce using rule 17 (var1 -> ID arr COMMA var1 .)
    RBRACKET        reduce using rule 17 (var1 -> ID arr COMMA var1 .)
    RPAREN          reduce using rule 17 (var1 -> ID arr COMMA var1 .)
    TO              reduce using rule 17 (var1 -> ID arr COMMA var1 .)
    COMMA           reduce using rule 17 (var1 -> ID arr COMMA var1 .)
    CTEI            reduce using rule 17 (var1 -> ID arr COMMA var1 .)
    CTEF            reduce using rule 17 (var1 -> ID arr COMMA var1 .)
    CTEC            reduce using rule 17 (var1 -> ID arr COMMA var1 .)
    LPAREN          reduce using rule 17 (var1 -> ID arr COMMA var1 .)
    ID              reduce using rule 17 (var1 -> ID arr COMMA var1 .)


state 105

    (18) var1 -> ID mat COMMA var1 .

    SEMICOLON       reduce using rule 18 (var1 -> ID mat COMMA var1 .)
    MUL             reduce using rule 18 (var1 -> ID mat COMMA var1 .)
    DIV             reduce using rule 18 (var1 -> ID mat COMMA var1 .)
    PLUS            reduce using rule 18 (var1 -> ID mat COMMA var1 .)
    MINUS           reduce using rule 18 (var1 -> ID mat COMMA var1 .)
    GT              reduce using rule 18 (var1 -> ID mat COMMA var1 .)
    LT              reduce using rule 18 (var1 -> ID mat COMMA var1 .)
    GTE             reduce using rule 18 (var1 -> ID mat COMMA var1 .)
    LTE             reduce using rule 18 (var1 -> ID mat COMMA var1 .)
    NE              reduce using rule 18 (var1 -> ID mat COMMA var1 .)
    AND             reduce using rule 18 (var1 -> ID mat COMMA var1 .)
    OR              reduce using rule 18 (var1 -> ID mat COMMA var1 .)
    RBRACKET        reduce using rule 18 (var1 -> ID mat COMMA var1 .)
    RPAREN          reduce using rule 18 (var1 -> ID mat COMMA var1 .)
    TO              reduce using rule 18 (var1 -> ID mat COMMA var1 .)
    COMMA           reduce using rule 18 (var1 -> ID mat COMMA var1 .)
    CTEI            reduce using rule 18 (var1 -> ID mat COMMA var1 .)
    CTEF            reduce using rule 18 (var1 -> ID mat COMMA var1 .)
    CTEC            reduce using rule 18 (var1 -> ID mat COMMA var1 .)
    LPAREN          reduce using rule 18 (var1 -> ID mat COMMA var1 .)
    ID              reduce using rule 18 (var1 -> ID mat COMMA var1 .)


state 106

    (31) mat -> LBRACKET CTEI RBRACKET LBRACKET . CTEI RBRACKET
    (34) mat -> LBRACKET CTEI RBRACKET LBRACKET . exp RBRACKET
    (77) exp -> . nexp
    (78) exp -> . nexp OR nexp
    (79) nexp -> . compexp
    (80) nexp -> . compexp AND compexp
    (81) compexp -> . sumexp
    (82) compexp -> . compexp1 sumexp
    (88) sumexp -> . mulexp
    (89) sumexp -> . mulexp PLUS mulexp
    (90) sumexp -> . mulexp MINUS mulexp
    (83) compexp1 -> . sumexp GT sumexp
    (84) compexp1 -> . sumexp LT sumexp
    (85) compexp1 -> . sumexp GTE sumexp
    (86) compexp1 -> . sumexp LTE sumexp
    (87) compexp1 -> . sumexp NE sumexp
    (91) mulexp -> . pexp
    (92) mulexp -> . pexp MUL pexp
    (93) mulexp -> . pexp DIV pexp
    (94) pexp -> . var1
    (95) pexp -> . CTEI
    (96) pexp -> . CTEF
    (97) pexp -> . CTEC
    (98) pexp -> . llamada
    (99) pexp -> . LPAREN exp RPAREN
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (61) llamada -> . ID LPAREN exp RPAREN
    (100) empty -> .

    CTEI            shift and go to state 139
    CTEF            shift and go to state 67
    CTEC            shift and go to state 68
    LPAREN          shift and go to state 70
    ID              shift and go to state 71
    MUL             reduce using rule 100 (empty -> .)
    DIV             reduce using rule 100 (empty -> .)
    PLUS            reduce using rule 100 (empty -> .)
    MINUS           reduce using rule 100 (empty -> .)
    GT              reduce using rule 100 (empty -> .)
    LT              reduce using rule 100 (empty -> .)
    GTE             reduce using rule 100 (empty -> .)
    LTE             reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    RBRACKET        reduce using rule 100 (empty -> .)

    exp                            shift and go to state 140
    nexp                           shift and go to state 60
    compexp                        shift and go to state 61
    sumexp                         shift and go to state 62
    compexp1                       shift and go to state 63
    mulexp                         shift and go to state 64
    pexp                           shift and go to state 65
    var1                           shift and go to state 66
    llamada                        shift and go to state 69
    empty                          shift and go to state 44

state 107

    (32) mat -> LBRACKET exp RBRACKET LBRACKET . exp RBRACKET
    (33) mat -> LBRACKET exp RBRACKET LBRACKET . CTEI RBRACKET
    (77) exp -> . nexp
    (78) exp -> . nexp OR nexp
    (79) nexp -> . compexp
    (80) nexp -> . compexp AND compexp
    (81) compexp -> . sumexp
    (82) compexp -> . compexp1 sumexp
    (88) sumexp -> . mulexp
    (89) sumexp -> . mulexp PLUS mulexp
    (90) sumexp -> . mulexp MINUS mulexp
    (83) compexp1 -> . sumexp GT sumexp
    (84) compexp1 -> . sumexp LT sumexp
    (85) compexp1 -> . sumexp GTE sumexp
    (86) compexp1 -> . sumexp LTE sumexp
    (87) compexp1 -> . sumexp NE sumexp
    (91) mulexp -> . pexp
    (92) mulexp -> . pexp MUL pexp
    (93) mulexp -> . pexp DIV pexp
    (94) pexp -> . var1
    (95) pexp -> . CTEI
    (96) pexp -> . CTEF
    (97) pexp -> . CTEC
    (98) pexp -> . llamada
    (99) pexp -> . LPAREN exp RPAREN
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (61) llamada -> . ID LPAREN exp RPAREN
    (100) empty -> .

    CTEI            shift and go to state 142
    CTEF            shift and go to state 67
    CTEC            shift and go to state 68
    LPAREN          shift and go to state 70
    ID              shift and go to state 71
    MUL             reduce using rule 100 (empty -> .)
    DIV             reduce using rule 100 (empty -> .)
    PLUS            reduce using rule 100 (empty -> .)
    MINUS           reduce using rule 100 (empty -> .)
    GT              reduce using rule 100 (empty -> .)
    LT              reduce using rule 100 (empty -> .)
    GTE             reduce using rule 100 (empty -> .)
    LTE             reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    RBRACKET        reduce using rule 100 (empty -> .)

    exp                            shift and go to state 141
    nexp                           shift and go to state 60
    compexp                        shift and go to state 61
    sumexp                         shift and go to state 62
    compexp1                       shift and go to state 63
    mulexp                         shift and go to state 64
    pexp                           shift and go to state 65
    var1                           shift and go to state 66
    llamada                        shift and go to state 69
    empty                          shift and go to state 44

state 108

    (78) exp -> nexp OR nexp .

    RBRACKET        reduce using rule 78 (exp -> nexp OR nexp .)
    RPAREN          reduce using rule 78 (exp -> nexp OR nexp .)
    SEMICOLON       reduce using rule 78 (exp -> nexp OR nexp .)
    TO              reduce using rule 78 (exp -> nexp OR nexp .)
    COMMA           reduce using rule 78 (exp -> nexp OR nexp .)


state 109

    (80) nexp -> compexp AND compexp .

    OR              reduce using rule 80 (nexp -> compexp AND compexp .)
    RBRACKET        reduce using rule 80 (nexp -> compexp AND compexp .)
    RPAREN          reduce using rule 80 (nexp -> compexp AND compexp .)
    SEMICOLON       reduce using rule 80 (nexp -> compexp AND compexp .)
    TO              reduce using rule 80 (nexp -> compexp AND compexp .)
    COMMA           reduce using rule 80 (nexp -> compexp AND compexp .)


state 110

    (83) compexp1 -> sumexp GT sumexp .

    CTEI            reduce using rule 83 (compexp1 -> sumexp GT sumexp .)
    CTEF            reduce using rule 83 (compexp1 -> sumexp GT sumexp .)
    CTEC            reduce using rule 83 (compexp1 -> sumexp GT sumexp .)
    LPAREN          reduce using rule 83 (compexp1 -> sumexp GT sumexp .)
    ID              reduce using rule 83 (compexp1 -> sumexp GT sumexp .)
    PLUS            reduce using rule 83 (compexp1 -> sumexp GT sumexp .)
    MINUS           reduce using rule 83 (compexp1 -> sumexp GT sumexp .)
    MUL             reduce using rule 83 (compexp1 -> sumexp GT sumexp .)
    DIV             reduce using rule 83 (compexp1 -> sumexp GT sumexp .)
    AND             reduce using rule 83 (compexp1 -> sumexp GT sumexp .)
    OR              reduce using rule 83 (compexp1 -> sumexp GT sumexp .)
    RBRACKET        reduce using rule 83 (compexp1 -> sumexp GT sumexp .)
    RPAREN          reduce using rule 83 (compexp1 -> sumexp GT sumexp .)
    SEMICOLON       reduce using rule 83 (compexp1 -> sumexp GT sumexp .)
    TO              reduce using rule 83 (compexp1 -> sumexp GT sumexp .)
    COMMA           reduce using rule 83 (compexp1 -> sumexp GT sumexp .)


state 111

    (84) compexp1 -> sumexp LT sumexp .

    CTEI            reduce using rule 84 (compexp1 -> sumexp LT sumexp .)
    CTEF            reduce using rule 84 (compexp1 -> sumexp LT sumexp .)
    CTEC            reduce using rule 84 (compexp1 -> sumexp LT sumexp .)
    LPAREN          reduce using rule 84 (compexp1 -> sumexp LT sumexp .)
    ID              reduce using rule 84 (compexp1 -> sumexp LT sumexp .)
    PLUS            reduce using rule 84 (compexp1 -> sumexp LT sumexp .)
    MINUS           reduce using rule 84 (compexp1 -> sumexp LT sumexp .)
    MUL             reduce using rule 84 (compexp1 -> sumexp LT sumexp .)
    DIV             reduce using rule 84 (compexp1 -> sumexp LT sumexp .)
    AND             reduce using rule 84 (compexp1 -> sumexp LT sumexp .)
    OR              reduce using rule 84 (compexp1 -> sumexp LT sumexp .)
    RBRACKET        reduce using rule 84 (compexp1 -> sumexp LT sumexp .)
    RPAREN          reduce using rule 84 (compexp1 -> sumexp LT sumexp .)
    SEMICOLON       reduce using rule 84 (compexp1 -> sumexp LT sumexp .)
    TO              reduce using rule 84 (compexp1 -> sumexp LT sumexp .)
    COMMA           reduce using rule 84 (compexp1 -> sumexp LT sumexp .)


state 112

    (85) compexp1 -> sumexp GTE sumexp .

    CTEI            reduce using rule 85 (compexp1 -> sumexp GTE sumexp .)
    CTEF            reduce using rule 85 (compexp1 -> sumexp GTE sumexp .)
    CTEC            reduce using rule 85 (compexp1 -> sumexp GTE sumexp .)
    LPAREN          reduce using rule 85 (compexp1 -> sumexp GTE sumexp .)
    ID              reduce using rule 85 (compexp1 -> sumexp GTE sumexp .)
    PLUS            reduce using rule 85 (compexp1 -> sumexp GTE sumexp .)
    MINUS           reduce using rule 85 (compexp1 -> sumexp GTE sumexp .)
    MUL             reduce using rule 85 (compexp1 -> sumexp GTE sumexp .)
    DIV             reduce using rule 85 (compexp1 -> sumexp GTE sumexp .)
    AND             reduce using rule 85 (compexp1 -> sumexp GTE sumexp .)
    OR              reduce using rule 85 (compexp1 -> sumexp GTE sumexp .)
    RBRACKET        reduce using rule 85 (compexp1 -> sumexp GTE sumexp .)
    RPAREN          reduce using rule 85 (compexp1 -> sumexp GTE sumexp .)
    SEMICOLON       reduce using rule 85 (compexp1 -> sumexp GTE sumexp .)
    TO              reduce using rule 85 (compexp1 -> sumexp GTE sumexp .)
    COMMA           reduce using rule 85 (compexp1 -> sumexp GTE sumexp .)


state 113

    (86) compexp1 -> sumexp LTE sumexp .

    CTEI            reduce using rule 86 (compexp1 -> sumexp LTE sumexp .)
    CTEF            reduce using rule 86 (compexp1 -> sumexp LTE sumexp .)
    CTEC            reduce using rule 86 (compexp1 -> sumexp LTE sumexp .)
    LPAREN          reduce using rule 86 (compexp1 -> sumexp LTE sumexp .)
    ID              reduce using rule 86 (compexp1 -> sumexp LTE sumexp .)
    PLUS            reduce using rule 86 (compexp1 -> sumexp LTE sumexp .)
    MINUS           reduce using rule 86 (compexp1 -> sumexp LTE sumexp .)
    MUL             reduce using rule 86 (compexp1 -> sumexp LTE sumexp .)
    DIV             reduce using rule 86 (compexp1 -> sumexp LTE sumexp .)
    AND             reduce using rule 86 (compexp1 -> sumexp LTE sumexp .)
    OR              reduce using rule 86 (compexp1 -> sumexp LTE sumexp .)
    RBRACKET        reduce using rule 86 (compexp1 -> sumexp LTE sumexp .)
    RPAREN          reduce using rule 86 (compexp1 -> sumexp LTE sumexp .)
    SEMICOLON       reduce using rule 86 (compexp1 -> sumexp LTE sumexp .)
    TO              reduce using rule 86 (compexp1 -> sumexp LTE sumexp .)
    COMMA           reduce using rule 86 (compexp1 -> sumexp LTE sumexp .)


state 114

    (87) compexp1 -> sumexp NE sumexp .

    CTEI            reduce using rule 87 (compexp1 -> sumexp NE sumexp .)
    CTEF            reduce using rule 87 (compexp1 -> sumexp NE sumexp .)
    CTEC            reduce using rule 87 (compexp1 -> sumexp NE sumexp .)
    LPAREN          reduce using rule 87 (compexp1 -> sumexp NE sumexp .)
    ID              reduce using rule 87 (compexp1 -> sumexp NE sumexp .)
    PLUS            reduce using rule 87 (compexp1 -> sumexp NE sumexp .)
    MINUS           reduce using rule 87 (compexp1 -> sumexp NE sumexp .)
    MUL             reduce using rule 87 (compexp1 -> sumexp NE sumexp .)
    DIV             reduce using rule 87 (compexp1 -> sumexp NE sumexp .)
    AND             reduce using rule 87 (compexp1 -> sumexp NE sumexp .)
    OR              reduce using rule 87 (compexp1 -> sumexp NE sumexp .)
    RBRACKET        reduce using rule 87 (compexp1 -> sumexp NE sumexp .)
    RPAREN          reduce using rule 87 (compexp1 -> sumexp NE sumexp .)
    SEMICOLON       reduce using rule 87 (compexp1 -> sumexp NE sumexp .)
    TO              reduce using rule 87 (compexp1 -> sumexp NE sumexp .)
    COMMA           reduce using rule 87 (compexp1 -> sumexp NE sumexp .)


state 115

    (89) sumexp -> mulexp PLUS mulexp .

    GT              reduce using rule 89 (sumexp -> mulexp PLUS mulexp .)
    LT              reduce using rule 89 (sumexp -> mulexp PLUS mulexp .)
    GTE             reduce using rule 89 (sumexp -> mulexp PLUS mulexp .)
    LTE             reduce using rule 89 (sumexp -> mulexp PLUS mulexp .)
    NE              reduce using rule 89 (sumexp -> mulexp PLUS mulexp .)
    AND             reduce using rule 89 (sumexp -> mulexp PLUS mulexp .)
    OR              reduce using rule 89 (sumexp -> mulexp PLUS mulexp .)
    RBRACKET        reduce using rule 89 (sumexp -> mulexp PLUS mulexp .)
    RPAREN          reduce using rule 89 (sumexp -> mulexp PLUS mulexp .)
    SEMICOLON       reduce using rule 89 (sumexp -> mulexp PLUS mulexp .)
    TO              reduce using rule 89 (sumexp -> mulexp PLUS mulexp .)
    COMMA           reduce using rule 89 (sumexp -> mulexp PLUS mulexp .)
    CTEI            reduce using rule 89 (sumexp -> mulexp PLUS mulexp .)
    CTEF            reduce using rule 89 (sumexp -> mulexp PLUS mulexp .)
    CTEC            reduce using rule 89 (sumexp -> mulexp PLUS mulexp .)
    LPAREN          reduce using rule 89 (sumexp -> mulexp PLUS mulexp .)
    ID              reduce using rule 89 (sumexp -> mulexp PLUS mulexp .)
    PLUS            reduce using rule 89 (sumexp -> mulexp PLUS mulexp .)
    MINUS           reduce using rule 89 (sumexp -> mulexp PLUS mulexp .)
    MUL             reduce using rule 89 (sumexp -> mulexp PLUS mulexp .)
    DIV             reduce using rule 89 (sumexp -> mulexp PLUS mulexp .)


state 116

    (90) sumexp -> mulexp MINUS mulexp .

    GT              reduce using rule 90 (sumexp -> mulexp MINUS mulexp .)
    LT              reduce using rule 90 (sumexp -> mulexp MINUS mulexp .)
    GTE             reduce using rule 90 (sumexp -> mulexp MINUS mulexp .)
    LTE             reduce using rule 90 (sumexp -> mulexp MINUS mulexp .)
    NE              reduce using rule 90 (sumexp -> mulexp MINUS mulexp .)
    AND             reduce using rule 90 (sumexp -> mulexp MINUS mulexp .)
    OR              reduce using rule 90 (sumexp -> mulexp MINUS mulexp .)
    RBRACKET        reduce using rule 90 (sumexp -> mulexp MINUS mulexp .)
    RPAREN          reduce using rule 90 (sumexp -> mulexp MINUS mulexp .)
    SEMICOLON       reduce using rule 90 (sumexp -> mulexp MINUS mulexp .)
    TO              reduce using rule 90 (sumexp -> mulexp MINUS mulexp .)
    COMMA           reduce using rule 90 (sumexp -> mulexp MINUS mulexp .)
    CTEI            reduce using rule 90 (sumexp -> mulexp MINUS mulexp .)
    CTEF            reduce using rule 90 (sumexp -> mulexp MINUS mulexp .)
    CTEC            reduce using rule 90 (sumexp -> mulexp MINUS mulexp .)
    LPAREN          reduce using rule 90 (sumexp -> mulexp MINUS mulexp .)
    ID              reduce using rule 90 (sumexp -> mulexp MINUS mulexp .)
    PLUS            reduce using rule 90 (sumexp -> mulexp MINUS mulexp .)
    MINUS           reduce using rule 90 (sumexp -> mulexp MINUS mulexp .)
    MUL             reduce using rule 90 (sumexp -> mulexp MINUS mulexp .)
    DIV             reduce using rule 90 (sumexp -> mulexp MINUS mulexp .)


state 117

    (92) mulexp -> pexp MUL pexp .

    PLUS            reduce using rule 92 (mulexp -> pexp MUL pexp .)
    MINUS           reduce using rule 92 (mulexp -> pexp MUL pexp .)
    GT              reduce using rule 92 (mulexp -> pexp MUL pexp .)
    LT              reduce using rule 92 (mulexp -> pexp MUL pexp .)
    GTE             reduce using rule 92 (mulexp -> pexp MUL pexp .)
    LTE             reduce using rule 92 (mulexp -> pexp MUL pexp .)
    NE              reduce using rule 92 (mulexp -> pexp MUL pexp .)
    AND             reduce using rule 92 (mulexp -> pexp MUL pexp .)
    OR              reduce using rule 92 (mulexp -> pexp MUL pexp .)
    RBRACKET        reduce using rule 92 (mulexp -> pexp MUL pexp .)
    RPAREN          reduce using rule 92 (mulexp -> pexp MUL pexp .)
    SEMICOLON       reduce using rule 92 (mulexp -> pexp MUL pexp .)
    TO              reduce using rule 92 (mulexp -> pexp MUL pexp .)
    COMMA           reduce using rule 92 (mulexp -> pexp MUL pexp .)
    CTEI            reduce using rule 92 (mulexp -> pexp MUL pexp .)
    CTEF            reduce using rule 92 (mulexp -> pexp MUL pexp .)
    CTEC            reduce using rule 92 (mulexp -> pexp MUL pexp .)
    LPAREN          reduce using rule 92 (mulexp -> pexp MUL pexp .)
    ID              reduce using rule 92 (mulexp -> pexp MUL pexp .)
    MUL             reduce using rule 92 (mulexp -> pexp MUL pexp .)
    DIV             reduce using rule 92 (mulexp -> pexp MUL pexp .)


state 118

    (93) mulexp -> pexp DIV pexp .

    PLUS            reduce using rule 93 (mulexp -> pexp DIV pexp .)
    MINUS           reduce using rule 93 (mulexp -> pexp DIV pexp .)
    GT              reduce using rule 93 (mulexp -> pexp DIV pexp .)
    LT              reduce using rule 93 (mulexp -> pexp DIV pexp .)
    GTE             reduce using rule 93 (mulexp -> pexp DIV pexp .)
    LTE             reduce using rule 93 (mulexp -> pexp DIV pexp .)
    NE              reduce using rule 93 (mulexp -> pexp DIV pexp .)
    AND             reduce using rule 93 (mulexp -> pexp DIV pexp .)
    OR              reduce using rule 93 (mulexp -> pexp DIV pexp .)
    RBRACKET        reduce using rule 93 (mulexp -> pexp DIV pexp .)
    RPAREN          reduce using rule 93 (mulexp -> pexp DIV pexp .)
    SEMICOLON       reduce using rule 93 (mulexp -> pexp DIV pexp .)
    TO              reduce using rule 93 (mulexp -> pexp DIV pexp .)
    COMMA           reduce using rule 93 (mulexp -> pexp DIV pexp .)
    CTEI            reduce using rule 93 (mulexp -> pexp DIV pexp .)
    CTEF            reduce using rule 93 (mulexp -> pexp DIV pexp .)
    CTEC            reduce using rule 93 (mulexp -> pexp DIV pexp .)
    LPAREN          reduce using rule 93 (mulexp -> pexp DIV pexp .)
    ID              reduce using rule 93 (mulexp -> pexp DIV pexp .)
    MUL             reduce using rule 93 (mulexp -> pexp DIV pexp .)
    DIV             reduce using rule 93 (mulexp -> pexp DIV pexp .)


state 119

    (99) pexp -> LPAREN exp RPAREN .

    MUL             reduce using rule 99 (pexp -> LPAREN exp RPAREN .)
    DIV             reduce using rule 99 (pexp -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 99 (pexp -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 99 (pexp -> LPAREN exp RPAREN .)
    GT              reduce using rule 99 (pexp -> LPAREN exp RPAREN .)
    LT              reduce using rule 99 (pexp -> LPAREN exp RPAREN .)
    GTE             reduce using rule 99 (pexp -> LPAREN exp RPAREN .)
    LTE             reduce using rule 99 (pexp -> LPAREN exp RPAREN .)
    NE              reduce using rule 99 (pexp -> LPAREN exp RPAREN .)
    AND             reduce using rule 99 (pexp -> LPAREN exp RPAREN .)
    OR              reduce using rule 99 (pexp -> LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 99 (pexp -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 99 (pexp -> LPAREN exp RPAREN .)
    SEMICOLON       reduce using rule 99 (pexp -> LPAREN exp RPAREN .)
    TO              reduce using rule 99 (pexp -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 99 (pexp -> LPAREN exp RPAREN .)
    CTEI            reduce using rule 99 (pexp -> LPAREN exp RPAREN .)
    CTEF            reduce using rule 99 (pexp -> LPAREN exp RPAREN .)
    CTEC            reduce using rule 99 (pexp -> LPAREN exp RPAREN .)
    LPAREN          reduce using rule 99 (pexp -> LPAREN exp RPAREN .)
    ID              reduce using rule 99 (pexp -> LPAREN exp RPAREN .)


state 120

    (61) llamada -> ID LPAREN exp . RPAREN

    RPAREN          shift and go to state 143


state 121

    (7) main -> MAIN LPAREN param RPAREN LCURLY vars statement . RCURLY END

    RCURLY          shift and go to state 144


state 122

    (44) statement -> statement1 . statement
    (44) statement -> . statement1 statement
    (45) statement -> . empty
    (46) statement1 -> . asignacion SEMICOLON
    (47) statement1 -> . llamada SEMICOLON
    (48) statement1 -> . lectura SEMICOLON
    (49) statement1 -> . escritura SEMICOLON
    (50) statement1 -> . for
    (51) statement1 -> . if
    (52) statement1 -> . while
    (100) empty -> .
    (53) asignacion -> . ID EQUALS exp
    (54) asignacion -> . ID arr EQUALS exp
    (55) asignacion -> . ID mat EQUALS exp
    (61) llamada -> . ID LPAREN exp RPAREN
    (76) lectura -> . READ LPAREN var1 RPAREN
    (69) escritura -> . PRINT LPAREN escritura1 RPAREN
    (66) for -> . FOR LPAREN for1 RPAREN LCURLY statement RCURLY
    (62) if -> . IF LPAREN exp RPAREN LCURLY statement RCURLY
    (63) if -> . IF LPAREN exp RPAREN LCURLY statement RCURLY else
    (68) while -> . WHILE LPAREN exp RPAREN LCURLY statement RCURLY

    RCURLY          reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)
    ID              shift and go to state 131
    READ            shift and go to state 132
    PRINT           shift and go to state 133
    FOR             shift and go to state 134
    IF              shift and go to state 135
    WHILE           shift and go to state 136

    statement1                     shift and go to state 122
    statement                      shift and go to state 145
    empty                          shift and go to state 123
    asignacion                     shift and go to state 124
    llamada                        shift and go to state 125
    lectura                        shift and go to state 126
    escritura                      shift and go to state 127
    for                            shift and go to state 128
    if                             shift and go to state 129
    while                          shift and go to state 130

state 123

    (45) statement -> empty .

    RCURLY          reduce using rule 45 (statement -> empty .)
    RETURN          reduce using rule 45 (statement -> empty .)


state 124

    (46) statement1 -> asignacion . SEMICOLON

    SEMICOLON       shift and go to state 146


state 125

    (47) statement1 -> llamada . SEMICOLON

    SEMICOLON       shift and go to state 147


state 126

    (48) statement1 -> lectura . SEMICOLON

    SEMICOLON       shift and go to state 148


state 127

    (49) statement1 -> escritura . SEMICOLON

    SEMICOLON       shift and go to state 149


state 128

    (50) statement1 -> for .

    ID              reduce using rule 50 (statement1 -> for .)
    READ            reduce using rule 50 (statement1 -> for .)
    PRINT           reduce using rule 50 (statement1 -> for .)
    FOR             reduce using rule 50 (statement1 -> for .)
    IF              reduce using rule 50 (statement1 -> for .)
    WHILE           reduce using rule 50 (statement1 -> for .)
    RCURLY          reduce using rule 50 (statement1 -> for .)
    RETURN          reduce using rule 50 (statement1 -> for .)


state 129

    (51) statement1 -> if .

    ID              reduce using rule 51 (statement1 -> if .)
    READ            reduce using rule 51 (statement1 -> if .)
    PRINT           reduce using rule 51 (statement1 -> if .)
    FOR             reduce using rule 51 (statement1 -> if .)
    IF              reduce using rule 51 (statement1 -> if .)
    WHILE           reduce using rule 51 (statement1 -> if .)
    RCURLY          reduce using rule 51 (statement1 -> if .)
    RETURN          reduce using rule 51 (statement1 -> if .)


state 130

    (52) statement1 -> while .

    ID              reduce using rule 52 (statement1 -> while .)
    READ            reduce using rule 52 (statement1 -> while .)
    PRINT           reduce using rule 52 (statement1 -> while .)
    FOR             reduce using rule 52 (statement1 -> while .)
    IF              reduce using rule 52 (statement1 -> while .)
    WHILE           reduce using rule 52 (statement1 -> while .)
    RCURLY          reduce using rule 52 (statement1 -> while .)
    RETURN          reduce using rule 52 (statement1 -> while .)


state 131

    (53) asignacion -> ID . EQUALS exp
    (54) asignacion -> ID . arr EQUALS exp
    (55) asignacion -> ID . mat EQUALS exp
    (61) llamada -> ID . LPAREN exp RPAREN
    (29) arr -> . LBRACKET CTEI RBRACKET
    (30) arr -> . LBRACKET exp RBRACKET
    (31) mat -> . LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET
    (32) mat -> . LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (33) mat -> . LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET
    (34) mat -> . LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET

    EQUALS          shift and go to state 150
    LPAREN          shift and go to state 99
    LBRACKET        shift and go to state 45

    arr                            shift and go to state 151
    mat                            shift and go to state 152

state 132

    (76) lectura -> READ . LPAREN var1 RPAREN

    LPAREN          shift and go to state 153


state 133

    (69) escritura -> PRINT . LPAREN escritura1 RPAREN

    LPAREN          shift and go to state 154


state 134

    (66) for -> FOR . LPAREN for1 RPAREN LCURLY statement RCURLY

    LPAREN          shift and go to state 155


state 135

    (62) if -> IF . LPAREN exp RPAREN LCURLY statement RCURLY
    (63) if -> IF . LPAREN exp RPAREN LCURLY statement RCURLY else

    LPAREN          shift and go to state 156


state 136

    (68) while -> WHILE . LPAREN exp RPAREN LCURLY statement RCURLY

    LPAREN          shift and go to state 157


state 137

    (42) function1 -> ID save_fun LPAREN param RPAREN . SEMICOLON LCURLY vars statement RCURLY

    SEMICOLON       shift and go to state 158


state 138

    (43) function2 -> ID save_fun LPAREN param RPAREN . SEMICOLON LCURLY vars statement RETURN exp SEMICOLON RCURLY

    SEMICOLON       shift and go to state 159


state 139

    (31) mat -> LBRACKET CTEI RBRACKET LBRACKET CTEI . RBRACKET
    (95) pexp -> CTEI .

  ! shift/reduce conflict for RBRACKET resolved as shift
    RBRACKET        shift and go to state 160
    MUL             reduce using rule 95 (pexp -> CTEI .)
    DIV             reduce using rule 95 (pexp -> CTEI .)
    PLUS            reduce using rule 95 (pexp -> CTEI .)
    MINUS           reduce using rule 95 (pexp -> CTEI .)
    GT              reduce using rule 95 (pexp -> CTEI .)
    LT              reduce using rule 95 (pexp -> CTEI .)
    GTE             reduce using rule 95 (pexp -> CTEI .)
    LTE             reduce using rule 95 (pexp -> CTEI .)
    NE              reduce using rule 95 (pexp -> CTEI .)
    AND             reduce using rule 95 (pexp -> CTEI .)
    OR              reduce using rule 95 (pexp -> CTEI .)

  ! RBRACKET        [ reduce using rule 95 (pexp -> CTEI .) ]


state 140

    (34) mat -> LBRACKET CTEI RBRACKET LBRACKET exp . RBRACKET

    RBRACKET        shift and go to state 161


state 141

    (32) mat -> LBRACKET exp RBRACKET LBRACKET exp . RBRACKET

    RBRACKET        shift and go to state 162


state 142

    (33) mat -> LBRACKET exp RBRACKET LBRACKET CTEI . RBRACKET
    (95) pexp -> CTEI .

  ! shift/reduce conflict for RBRACKET resolved as shift
    RBRACKET        shift and go to state 163
    MUL             reduce using rule 95 (pexp -> CTEI .)
    DIV             reduce using rule 95 (pexp -> CTEI .)
    PLUS            reduce using rule 95 (pexp -> CTEI .)
    MINUS           reduce using rule 95 (pexp -> CTEI .)
    GT              reduce using rule 95 (pexp -> CTEI .)
    LT              reduce using rule 95 (pexp -> CTEI .)
    GTE             reduce using rule 95 (pexp -> CTEI .)
    LTE             reduce using rule 95 (pexp -> CTEI .)
    NE              reduce using rule 95 (pexp -> CTEI .)
    AND             reduce using rule 95 (pexp -> CTEI .)
    OR              reduce using rule 95 (pexp -> CTEI .)

  ! RBRACKET        [ reduce using rule 95 (pexp -> CTEI .) ]


state 143

    (61) llamada -> ID LPAREN exp RPAREN .

    MUL             reduce using rule 61 (llamada -> ID LPAREN exp RPAREN .)
    DIV             reduce using rule 61 (llamada -> ID LPAREN exp RPAREN .)
    PLUS            reduce using rule 61 (llamada -> ID LPAREN exp RPAREN .)
    MINUS           reduce using rule 61 (llamada -> ID LPAREN exp RPAREN .)
    GT              reduce using rule 61 (llamada -> ID LPAREN exp RPAREN .)
    LT              reduce using rule 61 (llamada -> ID LPAREN exp RPAREN .)
    GTE             reduce using rule 61 (llamada -> ID LPAREN exp RPAREN .)
    LTE             reduce using rule 61 (llamada -> ID LPAREN exp RPAREN .)
    NE              reduce using rule 61 (llamada -> ID LPAREN exp RPAREN .)
    AND             reduce using rule 61 (llamada -> ID LPAREN exp RPAREN .)
    OR              reduce using rule 61 (llamada -> ID LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 61 (llamada -> ID LPAREN exp RPAREN .)
    RPAREN          reduce using rule 61 (llamada -> ID LPAREN exp RPAREN .)
    SEMICOLON       reduce using rule 61 (llamada -> ID LPAREN exp RPAREN .)
    TO              reduce using rule 61 (llamada -> ID LPAREN exp RPAREN .)
    COMMA           reduce using rule 61 (llamada -> ID LPAREN exp RPAREN .)
    CTEI            reduce using rule 61 (llamada -> ID LPAREN exp RPAREN .)
    CTEF            reduce using rule 61 (llamada -> ID LPAREN exp RPAREN .)
    CTEC            reduce using rule 61 (llamada -> ID LPAREN exp RPAREN .)
    LPAREN          reduce using rule 61 (llamada -> ID LPAREN exp RPAREN .)
    ID              reduce using rule 61 (llamada -> ID LPAREN exp RPAREN .)


state 144

    (7) main -> MAIN LPAREN param RPAREN LCURLY vars statement RCURLY . END

    END             shift and go to state 164


state 145

    (44) statement -> statement1 statement .

    RCURLY          reduce using rule 44 (statement -> statement1 statement .)
    RETURN          reduce using rule 44 (statement -> statement1 statement .)


state 146

    (46) statement1 -> asignacion SEMICOLON .

    ID              reduce using rule 46 (statement1 -> asignacion SEMICOLON .)
    READ            reduce using rule 46 (statement1 -> asignacion SEMICOLON .)
    PRINT           reduce using rule 46 (statement1 -> asignacion SEMICOLON .)
    FOR             reduce using rule 46 (statement1 -> asignacion SEMICOLON .)
    IF              reduce using rule 46 (statement1 -> asignacion SEMICOLON .)
    WHILE           reduce using rule 46 (statement1 -> asignacion SEMICOLON .)
    RCURLY          reduce using rule 46 (statement1 -> asignacion SEMICOLON .)
    RETURN          reduce using rule 46 (statement1 -> asignacion SEMICOLON .)


state 147

    (47) statement1 -> llamada SEMICOLON .

    ID              reduce using rule 47 (statement1 -> llamada SEMICOLON .)
    READ            reduce using rule 47 (statement1 -> llamada SEMICOLON .)
    PRINT           reduce using rule 47 (statement1 -> llamada SEMICOLON .)
    FOR             reduce using rule 47 (statement1 -> llamada SEMICOLON .)
    IF              reduce using rule 47 (statement1 -> llamada SEMICOLON .)
    WHILE           reduce using rule 47 (statement1 -> llamada SEMICOLON .)
    RCURLY          reduce using rule 47 (statement1 -> llamada SEMICOLON .)
    RETURN          reduce using rule 47 (statement1 -> llamada SEMICOLON .)


state 148

    (48) statement1 -> lectura SEMICOLON .

    ID              reduce using rule 48 (statement1 -> lectura SEMICOLON .)
    READ            reduce using rule 48 (statement1 -> lectura SEMICOLON .)
    PRINT           reduce using rule 48 (statement1 -> lectura SEMICOLON .)
    FOR             reduce using rule 48 (statement1 -> lectura SEMICOLON .)
    IF              reduce using rule 48 (statement1 -> lectura SEMICOLON .)
    WHILE           reduce using rule 48 (statement1 -> lectura SEMICOLON .)
    RCURLY          reduce using rule 48 (statement1 -> lectura SEMICOLON .)
    RETURN          reduce using rule 48 (statement1 -> lectura SEMICOLON .)


state 149

    (49) statement1 -> escritura SEMICOLON .

    ID              reduce using rule 49 (statement1 -> escritura SEMICOLON .)
    READ            reduce using rule 49 (statement1 -> escritura SEMICOLON .)
    PRINT           reduce using rule 49 (statement1 -> escritura SEMICOLON .)
    FOR             reduce using rule 49 (statement1 -> escritura SEMICOLON .)
    IF              reduce using rule 49 (statement1 -> escritura SEMICOLON .)
    WHILE           reduce using rule 49 (statement1 -> escritura SEMICOLON .)
    RCURLY          reduce using rule 49 (statement1 -> escritura SEMICOLON .)
    RETURN          reduce using rule 49 (statement1 -> escritura SEMICOLON .)


state 150

    (53) asignacion -> ID EQUALS . exp
    (77) exp -> . nexp
    (78) exp -> . nexp OR nexp
    (79) nexp -> . compexp
    (80) nexp -> . compexp AND compexp
    (81) compexp -> . sumexp
    (82) compexp -> . compexp1 sumexp
    (88) sumexp -> . mulexp
    (89) sumexp -> . mulexp PLUS mulexp
    (90) sumexp -> . mulexp MINUS mulexp
    (83) compexp1 -> . sumexp GT sumexp
    (84) compexp1 -> . sumexp LT sumexp
    (85) compexp1 -> . sumexp GTE sumexp
    (86) compexp1 -> . sumexp LTE sumexp
    (87) compexp1 -> . sumexp NE sumexp
    (91) mulexp -> . pexp
    (92) mulexp -> . pexp MUL pexp
    (93) mulexp -> . pexp DIV pexp
    (94) pexp -> . var1
    (95) pexp -> . CTEI
    (96) pexp -> . CTEF
    (97) pexp -> . CTEC
    (98) pexp -> . llamada
    (99) pexp -> . LPAREN exp RPAREN
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (61) llamada -> . ID LPAREN exp RPAREN
    (100) empty -> .

    CTEI            shift and go to state 93
    CTEF            shift and go to state 67
    CTEC            shift and go to state 68
    LPAREN          shift and go to state 70
    ID              shift and go to state 71
    MUL             reduce using rule 100 (empty -> .)
    DIV             reduce using rule 100 (empty -> .)
    PLUS            reduce using rule 100 (empty -> .)
    MINUS           reduce using rule 100 (empty -> .)
    GT              reduce using rule 100 (empty -> .)
    LT              reduce using rule 100 (empty -> .)
    GTE             reduce using rule 100 (empty -> .)
    LTE             reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    TO              reduce using rule 100 (empty -> .)

    exp                            shift and go to state 165
    nexp                           shift and go to state 60
    compexp                        shift and go to state 61
    sumexp                         shift and go to state 62
    compexp1                       shift and go to state 63
    mulexp                         shift and go to state 64
    pexp                           shift and go to state 65
    var1                           shift and go to state 66
    llamada                        shift and go to state 69
    empty                          shift and go to state 44

state 151

    (54) asignacion -> ID arr . EQUALS exp

    EQUALS          shift and go to state 166


state 152

    (55) asignacion -> ID mat . EQUALS exp

    EQUALS          shift and go to state 167


state 153

    (76) lectura -> READ LPAREN . var1 RPAREN
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (100) empty -> .

    ID              shift and go to state 43
    RPAREN          reduce using rule 100 (empty -> .)

    var1                           shift and go to state 168
    empty                          shift and go to state 44

state 154

    (69) escritura -> PRINT LPAREN . escritura1 RPAREN
    (70) escritura1 -> . escritura2 COMMA escritura2
    (71) escritura1 -> . escritura2
    (72) escritura2 -> . CTESTRING
    (73) escritura2 -> . CTEI
    (74) escritura2 -> . CTEF
    (75) escritura2 -> . exp
    (77) exp -> . nexp
    (78) exp -> . nexp OR nexp
    (79) nexp -> . compexp
    (80) nexp -> . compexp AND compexp
    (81) compexp -> . sumexp
    (82) compexp -> . compexp1 sumexp
    (88) sumexp -> . mulexp
    (89) sumexp -> . mulexp PLUS mulexp
    (90) sumexp -> . mulexp MINUS mulexp
    (83) compexp1 -> . sumexp GT sumexp
    (84) compexp1 -> . sumexp LT sumexp
    (85) compexp1 -> . sumexp GTE sumexp
    (86) compexp1 -> . sumexp LTE sumexp
    (87) compexp1 -> . sumexp NE sumexp
    (91) mulexp -> . pexp
    (92) mulexp -> . pexp MUL pexp
    (93) mulexp -> . pexp DIV pexp
    (94) pexp -> . var1
    (95) pexp -> . CTEI
    (96) pexp -> . CTEF
    (97) pexp -> . CTEC
    (98) pexp -> . llamada
    (99) pexp -> . LPAREN exp RPAREN
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (61) llamada -> . ID LPAREN exp RPAREN
    (100) empty -> .

    CTESTRING       shift and go to state 171
    CTEI            shift and go to state 172
    CTEF            shift and go to state 173
    CTEC            shift and go to state 68
    LPAREN          shift and go to state 70
    ID              shift and go to state 71
    MUL             reduce using rule 100 (empty -> .)
    DIV             reduce using rule 100 (empty -> .)
    PLUS            reduce using rule 100 (empty -> .)
    MINUS           reduce using rule 100 (empty -> .)
    GT              reduce using rule 100 (empty -> .)
    LT              reduce using rule 100 (empty -> .)
    GTE             reduce using rule 100 (empty -> .)
    LTE             reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    COMMA           reduce using rule 100 (empty -> .)
    RPAREN          reduce using rule 100 (empty -> .)

    escritura1                     shift and go to state 169
    escritura2                     shift and go to state 170
    exp                            shift and go to state 174
    nexp                           shift and go to state 60
    compexp                        shift and go to state 61
    sumexp                         shift and go to state 62
    compexp1                       shift and go to state 63
    mulexp                         shift and go to state 64
    pexp                           shift and go to state 65
    var1                           shift and go to state 66
    llamada                        shift and go to state 69
    empty                          shift and go to state 44

state 155

    (66) for -> FOR LPAREN . for1 RPAREN LCURLY statement RCURLY
    (67) for1 -> . FROM asignacion TO exp

    FROM            shift and go to state 176

    for1                           shift and go to state 175

state 156

    (62) if -> IF LPAREN . exp RPAREN LCURLY statement RCURLY
    (63) if -> IF LPAREN . exp RPAREN LCURLY statement RCURLY else
    (77) exp -> . nexp
    (78) exp -> . nexp OR nexp
    (79) nexp -> . compexp
    (80) nexp -> . compexp AND compexp
    (81) compexp -> . sumexp
    (82) compexp -> . compexp1 sumexp
    (88) sumexp -> . mulexp
    (89) sumexp -> . mulexp PLUS mulexp
    (90) sumexp -> . mulexp MINUS mulexp
    (83) compexp1 -> . sumexp GT sumexp
    (84) compexp1 -> . sumexp LT sumexp
    (85) compexp1 -> . sumexp GTE sumexp
    (86) compexp1 -> . sumexp LTE sumexp
    (87) compexp1 -> . sumexp NE sumexp
    (91) mulexp -> . pexp
    (92) mulexp -> . pexp MUL pexp
    (93) mulexp -> . pexp DIV pexp
    (94) pexp -> . var1
    (95) pexp -> . CTEI
    (96) pexp -> . CTEF
    (97) pexp -> . CTEC
    (98) pexp -> . llamada
    (99) pexp -> . LPAREN exp RPAREN
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (61) llamada -> . ID LPAREN exp RPAREN
    (100) empty -> .

    CTEI            shift and go to state 93
    CTEF            shift and go to state 67
    CTEC            shift and go to state 68
    LPAREN          shift and go to state 70
    ID              shift and go to state 71
    MUL             reduce using rule 100 (empty -> .)
    DIV             reduce using rule 100 (empty -> .)
    PLUS            reduce using rule 100 (empty -> .)
    MINUS           reduce using rule 100 (empty -> .)
    GT              reduce using rule 100 (empty -> .)
    LT              reduce using rule 100 (empty -> .)
    GTE             reduce using rule 100 (empty -> .)
    LTE             reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    RPAREN          reduce using rule 100 (empty -> .)

    exp                            shift and go to state 177
    nexp                           shift and go to state 60
    compexp                        shift and go to state 61
    sumexp                         shift and go to state 62
    compexp1                       shift and go to state 63
    mulexp                         shift and go to state 64
    pexp                           shift and go to state 65
    var1                           shift and go to state 66
    llamada                        shift and go to state 69
    empty                          shift and go to state 44

state 157

    (68) while -> WHILE LPAREN . exp RPAREN LCURLY statement RCURLY
    (77) exp -> . nexp
    (78) exp -> . nexp OR nexp
    (79) nexp -> . compexp
    (80) nexp -> . compexp AND compexp
    (81) compexp -> . sumexp
    (82) compexp -> . compexp1 sumexp
    (88) sumexp -> . mulexp
    (89) sumexp -> . mulexp PLUS mulexp
    (90) sumexp -> . mulexp MINUS mulexp
    (83) compexp1 -> . sumexp GT sumexp
    (84) compexp1 -> . sumexp LT sumexp
    (85) compexp1 -> . sumexp GTE sumexp
    (86) compexp1 -> . sumexp LTE sumexp
    (87) compexp1 -> . sumexp NE sumexp
    (91) mulexp -> . pexp
    (92) mulexp -> . pexp MUL pexp
    (93) mulexp -> . pexp DIV pexp
    (94) pexp -> . var1
    (95) pexp -> . CTEI
    (96) pexp -> . CTEF
    (97) pexp -> . CTEC
    (98) pexp -> . llamada
    (99) pexp -> . LPAREN exp RPAREN
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (61) llamada -> . ID LPAREN exp RPAREN
    (100) empty -> .

    CTEI            shift and go to state 93
    CTEF            shift and go to state 67
    CTEC            shift and go to state 68
    LPAREN          shift and go to state 70
    ID              shift and go to state 71
    MUL             reduce using rule 100 (empty -> .)
    DIV             reduce using rule 100 (empty -> .)
    PLUS            reduce using rule 100 (empty -> .)
    MINUS           reduce using rule 100 (empty -> .)
    GT              reduce using rule 100 (empty -> .)
    LT              reduce using rule 100 (empty -> .)
    GTE             reduce using rule 100 (empty -> .)
    LTE             reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    RPAREN          reduce using rule 100 (empty -> .)

    exp                            shift and go to state 178
    nexp                           shift and go to state 60
    compexp                        shift and go to state 61
    sumexp                         shift and go to state 62
    compexp1                       shift and go to state 63
    mulexp                         shift and go to state 64
    pexp                           shift and go to state 65
    var1                           shift and go to state 66
    llamada                        shift and go to state 69
    empty                          shift and go to state 44

state 158

    (42) function1 -> ID save_fun LPAREN param RPAREN SEMICOLON . LCURLY vars statement RCURLY

    LCURLY          shift and go to state 179


state 159

    (43) function2 -> ID save_fun LPAREN param RPAREN SEMICOLON . LCURLY vars statement RETURN exp SEMICOLON RCURLY

    LCURLY          shift and go to state 180


state 160

    (31) mat -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET .

    SEMICOLON       reduce using rule 31 (mat -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET .)
    COMMA           reduce using rule 31 (mat -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET .)
    TRANSPUESTA     reduce using rule 31 (mat -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET .)
    INVERSA         reduce using rule 31 (mat -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET .)
    DETERMINANTE    reduce using rule 31 (mat -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET .)
    MUL             reduce using rule 31 (mat -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET .)
    DIV             reduce using rule 31 (mat -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET .)
    PLUS            reduce using rule 31 (mat -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET .)
    MINUS           reduce using rule 31 (mat -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET .)
    GT              reduce using rule 31 (mat -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET .)
    LT              reduce using rule 31 (mat -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET .)
    GTE             reduce using rule 31 (mat -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET .)
    LTE             reduce using rule 31 (mat -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET .)
    NE              reduce using rule 31 (mat -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET .)
    AND             reduce using rule 31 (mat -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET .)
    OR              reduce using rule 31 (mat -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET .)
    RBRACKET        reduce using rule 31 (mat -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET .)
    RPAREN          reduce using rule 31 (mat -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET .)
    TO              reduce using rule 31 (mat -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET .)
    CTEI            reduce using rule 31 (mat -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET .)
    CTEF            reduce using rule 31 (mat -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET .)
    CTEC            reduce using rule 31 (mat -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET .)
    LPAREN          reduce using rule 31 (mat -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET .)
    ID              reduce using rule 31 (mat -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET .)
    EQUALS          reduce using rule 31 (mat -> LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET .)


state 161

    (34) mat -> LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET .

    SEMICOLON       reduce using rule 34 (mat -> LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET .)
    COMMA           reduce using rule 34 (mat -> LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET .)
    TRANSPUESTA     reduce using rule 34 (mat -> LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET .)
    INVERSA         reduce using rule 34 (mat -> LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET .)
    DETERMINANTE    reduce using rule 34 (mat -> LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET .)
    MUL             reduce using rule 34 (mat -> LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET .)
    DIV             reduce using rule 34 (mat -> LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET .)
    PLUS            reduce using rule 34 (mat -> LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 34 (mat -> LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET .)
    GT              reduce using rule 34 (mat -> LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET .)
    LT              reduce using rule 34 (mat -> LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET .)
    GTE             reduce using rule 34 (mat -> LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET .)
    LTE             reduce using rule 34 (mat -> LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET .)
    NE              reduce using rule 34 (mat -> LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET .)
    AND             reduce using rule 34 (mat -> LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET .)
    OR              reduce using rule 34 (mat -> LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 34 (mat -> LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 34 (mat -> LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET .)
    TO              reduce using rule 34 (mat -> LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET .)
    CTEI            reduce using rule 34 (mat -> LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET .)
    CTEF            reduce using rule 34 (mat -> LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET .)
    CTEC            reduce using rule 34 (mat -> LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET .)
    LPAREN          reduce using rule 34 (mat -> LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET .)
    ID              reduce using rule 34 (mat -> LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET .)
    EQUALS          reduce using rule 34 (mat -> LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET .)


state 162

    (32) mat -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET .

    SEMICOLON       reduce using rule 32 (mat -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    COMMA           reduce using rule 32 (mat -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    TRANSPUESTA     reduce using rule 32 (mat -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    INVERSA         reduce using rule 32 (mat -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    DETERMINANTE    reduce using rule 32 (mat -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    MUL             reduce using rule 32 (mat -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    DIV             reduce using rule 32 (mat -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    PLUS            reduce using rule 32 (mat -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 32 (mat -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    GT              reduce using rule 32 (mat -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    LT              reduce using rule 32 (mat -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    GTE             reduce using rule 32 (mat -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    LTE             reduce using rule 32 (mat -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    NE              reduce using rule 32 (mat -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    AND             reduce using rule 32 (mat -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    OR              reduce using rule 32 (mat -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 32 (mat -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 32 (mat -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    TO              reduce using rule 32 (mat -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    CTEI            reduce using rule 32 (mat -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    CTEF            reduce using rule 32 (mat -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    CTEC            reduce using rule 32 (mat -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    LPAREN          reduce using rule 32 (mat -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    ID              reduce using rule 32 (mat -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    EQUALS          reduce using rule 32 (mat -> LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)


state 163

    (33) mat -> LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET .

    SEMICOLON       reduce using rule 33 (mat -> LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET .)
    COMMA           reduce using rule 33 (mat -> LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET .)
    TRANSPUESTA     reduce using rule 33 (mat -> LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET .)
    INVERSA         reduce using rule 33 (mat -> LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET .)
    DETERMINANTE    reduce using rule 33 (mat -> LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET .)
    MUL             reduce using rule 33 (mat -> LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET .)
    DIV             reduce using rule 33 (mat -> LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET .)
    PLUS            reduce using rule 33 (mat -> LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET .)
    MINUS           reduce using rule 33 (mat -> LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET .)
    GT              reduce using rule 33 (mat -> LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET .)
    LT              reduce using rule 33 (mat -> LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET .)
    GTE             reduce using rule 33 (mat -> LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET .)
    LTE             reduce using rule 33 (mat -> LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET .)
    NE              reduce using rule 33 (mat -> LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET .)
    AND             reduce using rule 33 (mat -> LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET .)
    OR              reduce using rule 33 (mat -> LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET .)
    RBRACKET        reduce using rule 33 (mat -> LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET .)
    RPAREN          reduce using rule 33 (mat -> LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET .)
    TO              reduce using rule 33 (mat -> LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET .)
    CTEI            reduce using rule 33 (mat -> LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET .)
    CTEF            reduce using rule 33 (mat -> LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET .)
    CTEC            reduce using rule 33 (mat -> LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET .)
    LPAREN          reduce using rule 33 (mat -> LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET .)
    ID              reduce using rule 33 (mat -> LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET .)
    EQUALS          reduce using rule 33 (mat -> LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET .)


state 164

    (7) main -> MAIN LPAREN param RPAREN LCURLY vars statement RCURLY END .

    $end            reduce using rule 7 (main -> MAIN LPAREN param RPAREN LCURLY vars statement RCURLY END .)


state 165

    (53) asignacion -> ID EQUALS exp .

    SEMICOLON       reduce using rule 53 (asignacion -> ID EQUALS exp .)
    TO              reduce using rule 53 (asignacion -> ID EQUALS exp .)


state 166

    (54) asignacion -> ID arr EQUALS . exp
    (77) exp -> . nexp
    (78) exp -> . nexp OR nexp
    (79) nexp -> . compexp
    (80) nexp -> . compexp AND compexp
    (81) compexp -> . sumexp
    (82) compexp -> . compexp1 sumexp
    (88) sumexp -> . mulexp
    (89) sumexp -> . mulexp PLUS mulexp
    (90) sumexp -> . mulexp MINUS mulexp
    (83) compexp1 -> . sumexp GT sumexp
    (84) compexp1 -> . sumexp LT sumexp
    (85) compexp1 -> . sumexp GTE sumexp
    (86) compexp1 -> . sumexp LTE sumexp
    (87) compexp1 -> . sumexp NE sumexp
    (91) mulexp -> . pexp
    (92) mulexp -> . pexp MUL pexp
    (93) mulexp -> . pexp DIV pexp
    (94) pexp -> . var1
    (95) pexp -> . CTEI
    (96) pexp -> . CTEF
    (97) pexp -> . CTEC
    (98) pexp -> . llamada
    (99) pexp -> . LPAREN exp RPAREN
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (61) llamada -> . ID LPAREN exp RPAREN
    (100) empty -> .

    CTEI            shift and go to state 93
    CTEF            shift and go to state 67
    CTEC            shift and go to state 68
    LPAREN          shift and go to state 70
    ID              shift and go to state 71
    MUL             reduce using rule 100 (empty -> .)
    DIV             reduce using rule 100 (empty -> .)
    PLUS            reduce using rule 100 (empty -> .)
    MINUS           reduce using rule 100 (empty -> .)
    GT              reduce using rule 100 (empty -> .)
    LT              reduce using rule 100 (empty -> .)
    GTE             reduce using rule 100 (empty -> .)
    LTE             reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    TO              reduce using rule 100 (empty -> .)

    exp                            shift and go to state 181
    nexp                           shift and go to state 60
    compexp                        shift and go to state 61
    sumexp                         shift and go to state 62
    compexp1                       shift and go to state 63
    mulexp                         shift and go to state 64
    pexp                           shift and go to state 65
    var1                           shift and go to state 66
    llamada                        shift and go to state 69
    empty                          shift and go to state 44

state 167

    (55) asignacion -> ID mat EQUALS . exp
    (77) exp -> . nexp
    (78) exp -> . nexp OR nexp
    (79) nexp -> . compexp
    (80) nexp -> . compexp AND compexp
    (81) compexp -> . sumexp
    (82) compexp -> . compexp1 sumexp
    (88) sumexp -> . mulexp
    (89) sumexp -> . mulexp PLUS mulexp
    (90) sumexp -> . mulexp MINUS mulexp
    (83) compexp1 -> . sumexp GT sumexp
    (84) compexp1 -> . sumexp LT sumexp
    (85) compexp1 -> . sumexp GTE sumexp
    (86) compexp1 -> . sumexp LTE sumexp
    (87) compexp1 -> . sumexp NE sumexp
    (91) mulexp -> . pexp
    (92) mulexp -> . pexp MUL pexp
    (93) mulexp -> . pexp DIV pexp
    (94) pexp -> . var1
    (95) pexp -> . CTEI
    (96) pexp -> . CTEF
    (97) pexp -> . CTEC
    (98) pexp -> . llamada
    (99) pexp -> . LPAREN exp RPAREN
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (61) llamada -> . ID LPAREN exp RPAREN
    (100) empty -> .

    CTEI            shift and go to state 93
    CTEF            shift and go to state 67
    CTEC            shift and go to state 68
    LPAREN          shift and go to state 70
    ID              shift and go to state 71
    MUL             reduce using rule 100 (empty -> .)
    DIV             reduce using rule 100 (empty -> .)
    PLUS            reduce using rule 100 (empty -> .)
    MINUS           reduce using rule 100 (empty -> .)
    GT              reduce using rule 100 (empty -> .)
    LT              reduce using rule 100 (empty -> .)
    GTE             reduce using rule 100 (empty -> .)
    LTE             reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)
    TO              reduce using rule 100 (empty -> .)

    exp                            shift and go to state 182
    nexp                           shift and go to state 60
    compexp                        shift and go to state 61
    sumexp                         shift and go to state 62
    compexp1                       shift and go to state 63
    mulexp                         shift and go to state 64
    pexp                           shift and go to state 65
    var1                           shift and go to state 66
    llamada                        shift and go to state 69
    empty                          shift and go to state 44

state 168

    (76) lectura -> READ LPAREN var1 . RPAREN

    RPAREN          shift and go to state 183


state 169

    (69) escritura -> PRINT LPAREN escritura1 . RPAREN

    RPAREN          shift and go to state 184


state 170

    (70) escritura1 -> escritura2 . COMMA escritura2
    (71) escritura1 -> escritura2 .

    COMMA           shift and go to state 185
    RPAREN          reduce using rule 71 (escritura1 -> escritura2 .)


state 171

    (72) escritura2 -> CTESTRING .

    COMMA           reduce using rule 72 (escritura2 -> CTESTRING .)
    RPAREN          reduce using rule 72 (escritura2 -> CTESTRING .)


state 172

    (73) escritura2 -> CTEI .
    (95) pexp -> CTEI .

  ! reduce/reduce conflict for COMMA resolved using rule 73 (escritura2 -> CTEI .)
  ! reduce/reduce conflict for RPAREN resolved using rule 73 (escritura2 -> CTEI .)
    COMMA           reduce using rule 73 (escritura2 -> CTEI .)
    RPAREN          reduce using rule 73 (escritura2 -> CTEI .)
    MUL             reduce using rule 95 (pexp -> CTEI .)
    DIV             reduce using rule 95 (pexp -> CTEI .)
    PLUS            reduce using rule 95 (pexp -> CTEI .)
    MINUS           reduce using rule 95 (pexp -> CTEI .)
    GT              reduce using rule 95 (pexp -> CTEI .)
    LT              reduce using rule 95 (pexp -> CTEI .)
    GTE             reduce using rule 95 (pexp -> CTEI .)
    LTE             reduce using rule 95 (pexp -> CTEI .)
    NE              reduce using rule 95 (pexp -> CTEI .)
    AND             reduce using rule 95 (pexp -> CTEI .)
    OR              reduce using rule 95 (pexp -> CTEI .)

  ! COMMA           [ reduce using rule 95 (pexp -> CTEI .) ]
  ! RPAREN          [ reduce using rule 95 (pexp -> CTEI .) ]


state 173

    (74) escritura2 -> CTEF .
    (96) pexp -> CTEF .

  ! reduce/reduce conflict for COMMA resolved using rule 74 (escritura2 -> CTEF .)
  ! reduce/reduce conflict for RPAREN resolved using rule 74 (escritura2 -> CTEF .)
    COMMA           reduce using rule 74 (escritura2 -> CTEF .)
    RPAREN          reduce using rule 74 (escritura2 -> CTEF .)
    MUL             reduce using rule 96 (pexp -> CTEF .)
    DIV             reduce using rule 96 (pexp -> CTEF .)
    PLUS            reduce using rule 96 (pexp -> CTEF .)
    MINUS           reduce using rule 96 (pexp -> CTEF .)
    GT              reduce using rule 96 (pexp -> CTEF .)
    LT              reduce using rule 96 (pexp -> CTEF .)
    GTE             reduce using rule 96 (pexp -> CTEF .)
    LTE             reduce using rule 96 (pexp -> CTEF .)
    NE              reduce using rule 96 (pexp -> CTEF .)
    AND             reduce using rule 96 (pexp -> CTEF .)
    OR              reduce using rule 96 (pexp -> CTEF .)

  ! COMMA           [ reduce using rule 96 (pexp -> CTEF .) ]
  ! RPAREN          [ reduce using rule 96 (pexp -> CTEF .) ]


state 174

    (75) escritura2 -> exp .

    COMMA           reduce using rule 75 (escritura2 -> exp .)
    RPAREN          reduce using rule 75 (escritura2 -> exp .)


state 175

    (66) for -> FOR LPAREN for1 . RPAREN LCURLY statement RCURLY

    RPAREN          shift and go to state 186


state 176

    (67) for1 -> FROM . asignacion TO exp
    (53) asignacion -> . ID EQUALS exp
    (54) asignacion -> . ID arr EQUALS exp
    (55) asignacion -> . ID mat EQUALS exp

    ID              shift and go to state 188

    asignacion                     shift and go to state 187

state 177

    (62) if -> IF LPAREN exp . RPAREN LCURLY statement RCURLY
    (63) if -> IF LPAREN exp . RPAREN LCURLY statement RCURLY else

    RPAREN          shift and go to state 189


state 178

    (68) while -> WHILE LPAREN exp . RPAREN LCURLY statement RCURLY

    RPAREN          shift and go to state 190


state 179

    (42) function1 -> ID save_fun LPAREN param RPAREN SEMICOLON LCURLY . vars statement RCURLY
    (11) vars -> . var
    (12) vars -> . empty
    (13) var -> . VAR var2
    (100) empty -> .

    VAR             shift and go to state 12
    ID              reduce using rule 100 (empty -> .)
    READ            reduce using rule 100 (empty -> .)
    PRINT           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    RCURLY          reduce using rule 100 (empty -> .)

    vars                           shift and go to state 191
    var                            shift and go to state 9
    empty                          shift and go to state 10

state 180

    (43) function2 -> ID save_fun LPAREN param RPAREN SEMICOLON LCURLY . vars statement RETURN exp SEMICOLON RCURLY
    (11) vars -> . var
    (12) vars -> . empty
    (13) var -> . VAR var2
    (100) empty -> .

    VAR             shift and go to state 12
    ID              reduce using rule 100 (empty -> .)
    READ            reduce using rule 100 (empty -> .)
    PRINT           reduce using rule 100 (empty -> .)
    FOR             reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    WHILE           reduce using rule 100 (empty -> .)
    RETURN          reduce using rule 100 (empty -> .)

    vars                           shift and go to state 192
    var                            shift and go to state 9
    empty                          shift and go to state 10

state 181

    (54) asignacion -> ID arr EQUALS exp .

    SEMICOLON       reduce using rule 54 (asignacion -> ID arr EQUALS exp .)
    TO              reduce using rule 54 (asignacion -> ID arr EQUALS exp .)


state 182

    (55) asignacion -> ID mat EQUALS exp .

    SEMICOLON       reduce using rule 55 (asignacion -> ID mat EQUALS exp .)
    TO              reduce using rule 55 (asignacion -> ID mat EQUALS exp .)


state 183

    (76) lectura -> READ LPAREN var1 RPAREN .

    SEMICOLON       reduce using rule 76 (lectura -> READ LPAREN var1 RPAREN .)


state 184

    (69) escritura -> PRINT LPAREN escritura1 RPAREN .

    SEMICOLON       reduce using rule 69 (escritura -> PRINT LPAREN escritura1 RPAREN .)


state 185

    (70) escritura1 -> escritura2 COMMA . escritura2
    (72) escritura2 -> . CTESTRING
    (73) escritura2 -> . CTEI
    (74) escritura2 -> . CTEF
    (75) escritura2 -> . exp
    (77) exp -> . nexp
    (78) exp -> . nexp OR nexp
    (79) nexp -> . compexp
    (80) nexp -> . compexp AND compexp
    (81) compexp -> . sumexp
    (82) compexp -> . compexp1 sumexp
    (88) sumexp -> . mulexp
    (89) sumexp -> . mulexp PLUS mulexp
    (90) sumexp -> . mulexp MINUS mulexp
    (83) compexp1 -> . sumexp GT sumexp
    (84) compexp1 -> . sumexp LT sumexp
    (85) compexp1 -> . sumexp GTE sumexp
    (86) compexp1 -> . sumexp LTE sumexp
    (87) compexp1 -> . sumexp NE sumexp
    (91) mulexp -> . pexp
    (92) mulexp -> . pexp MUL pexp
    (93) mulexp -> . pexp DIV pexp
    (94) pexp -> . var1
    (95) pexp -> . CTEI
    (96) pexp -> . CTEF
    (97) pexp -> . CTEC
    (98) pexp -> . llamada
    (99) pexp -> . LPAREN exp RPAREN
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (61) llamada -> . ID LPAREN exp RPAREN
    (100) empty -> .

    CTESTRING       shift and go to state 171
    CTEI            shift and go to state 172
    CTEF            shift and go to state 173
    CTEC            shift and go to state 68
    LPAREN          shift and go to state 70
    ID              shift and go to state 71
    MUL             reduce using rule 100 (empty -> .)
    DIV             reduce using rule 100 (empty -> .)
    PLUS            reduce using rule 100 (empty -> .)
    MINUS           reduce using rule 100 (empty -> .)
    GT              reduce using rule 100 (empty -> .)
    LT              reduce using rule 100 (empty -> .)
    GTE             reduce using rule 100 (empty -> .)
    LTE             reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    RPAREN          reduce using rule 100 (empty -> .)

    escritura2                     shift and go to state 193
    exp                            shift and go to state 174
    nexp                           shift and go to state 60
    compexp                        shift and go to state 61
    sumexp                         shift and go to state 62
    compexp1                       shift and go to state 63
    mulexp                         shift and go to state 64
    pexp                           shift and go to state 65
    var1                           shift and go to state 66
    llamada                        shift and go to state 69
    empty                          shift and go to state 44

state 186

    (66) for -> FOR LPAREN for1 RPAREN . LCURLY statement RCURLY

    LCURLY          shift and go to state 194


state 187

    (67) for1 -> FROM asignacion . TO exp

    TO              shift and go to state 195


state 188

    (53) asignacion -> ID . EQUALS exp
    (54) asignacion -> ID . arr EQUALS exp
    (55) asignacion -> ID . mat EQUALS exp
    (29) arr -> . LBRACKET CTEI RBRACKET
    (30) arr -> . LBRACKET exp RBRACKET
    (31) mat -> . LBRACKET CTEI RBRACKET LBRACKET CTEI RBRACKET
    (32) mat -> . LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (33) mat -> . LBRACKET exp RBRACKET LBRACKET CTEI RBRACKET
    (34) mat -> . LBRACKET CTEI RBRACKET LBRACKET exp RBRACKET

    EQUALS          shift and go to state 150
    LBRACKET        shift and go to state 45

    arr                            shift and go to state 151
    mat                            shift and go to state 152

state 189

    (62) if -> IF LPAREN exp RPAREN . LCURLY statement RCURLY
    (63) if -> IF LPAREN exp RPAREN . LCURLY statement RCURLY else

    LCURLY          shift and go to state 196


state 190

    (68) while -> WHILE LPAREN exp RPAREN . LCURLY statement RCURLY

    LCURLY          shift and go to state 197


state 191

    (42) function1 -> ID save_fun LPAREN param RPAREN SEMICOLON LCURLY vars . statement RCURLY
    (44) statement -> . statement1 statement
    (45) statement -> . empty
    (46) statement1 -> . asignacion SEMICOLON
    (47) statement1 -> . llamada SEMICOLON
    (48) statement1 -> . lectura SEMICOLON
    (49) statement1 -> . escritura SEMICOLON
    (50) statement1 -> . for
    (51) statement1 -> . if
    (52) statement1 -> . while
    (100) empty -> .
    (53) asignacion -> . ID EQUALS exp
    (54) asignacion -> . ID arr EQUALS exp
    (55) asignacion -> . ID mat EQUALS exp
    (61) llamada -> . ID LPAREN exp RPAREN
    (76) lectura -> . READ LPAREN var1 RPAREN
    (69) escritura -> . PRINT LPAREN escritura1 RPAREN
    (66) for -> . FOR LPAREN for1 RPAREN LCURLY statement RCURLY
    (62) if -> . IF LPAREN exp RPAREN LCURLY statement RCURLY
    (63) if -> . IF LPAREN exp RPAREN LCURLY statement RCURLY else
    (68) while -> . WHILE LPAREN exp RPAREN LCURLY statement RCURLY

    RCURLY          reduce using rule 100 (empty -> .)
    ID              shift and go to state 131
    READ            shift and go to state 132
    PRINT           shift and go to state 133
    FOR             shift and go to state 134
    IF              shift and go to state 135
    WHILE           shift and go to state 136

    statement                      shift and go to state 198
    statement1                     shift and go to state 122
    empty                          shift and go to state 123
    asignacion                     shift and go to state 124
    llamada                        shift and go to state 125
    lectura                        shift and go to state 126
    escritura                      shift and go to state 127
    for                            shift and go to state 128
    if                             shift and go to state 129
    while                          shift and go to state 130

state 192

    (43) function2 -> ID save_fun LPAREN param RPAREN SEMICOLON LCURLY vars . statement RETURN exp SEMICOLON RCURLY
    (44) statement -> . statement1 statement
    (45) statement -> . empty
    (46) statement1 -> . asignacion SEMICOLON
    (47) statement1 -> . llamada SEMICOLON
    (48) statement1 -> . lectura SEMICOLON
    (49) statement1 -> . escritura SEMICOLON
    (50) statement1 -> . for
    (51) statement1 -> . if
    (52) statement1 -> . while
    (100) empty -> .
    (53) asignacion -> . ID EQUALS exp
    (54) asignacion -> . ID arr EQUALS exp
    (55) asignacion -> . ID mat EQUALS exp
    (61) llamada -> . ID LPAREN exp RPAREN
    (76) lectura -> . READ LPAREN var1 RPAREN
    (69) escritura -> . PRINT LPAREN escritura1 RPAREN
    (66) for -> . FOR LPAREN for1 RPAREN LCURLY statement RCURLY
    (62) if -> . IF LPAREN exp RPAREN LCURLY statement RCURLY
    (63) if -> . IF LPAREN exp RPAREN LCURLY statement RCURLY else
    (68) while -> . WHILE LPAREN exp RPAREN LCURLY statement RCURLY

    RETURN          reduce using rule 100 (empty -> .)
    ID              shift and go to state 131
    READ            shift and go to state 132
    PRINT           shift and go to state 133
    FOR             shift and go to state 134
    IF              shift and go to state 135
    WHILE           shift and go to state 136

    statement                      shift and go to state 199
    statement1                     shift and go to state 122
    empty                          shift and go to state 123
    asignacion                     shift and go to state 124
    llamada                        shift and go to state 125
    lectura                        shift and go to state 126
    escritura                      shift and go to state 127
    for                            shift and go to state 128
    if                             shift and go to state 129
    while                          shift and go to state 130

state 193

    (70) escritura1 -> escritura2 COMMA escritura2 .

    RPAREN          reduce using rule 70 (escritura1 -> escritura2 COMMA escritura2 .)


state 194

    (66) for -> FOR LPAREN for1 RPAREN LCURLY . statement RCURLY
    (44) statement -> . statement1 statement
    (45) statement -> . empty
    (46) statement1 -> . asignacion SEMICOLON
    (47) statement1 -> . llamada SEMICOLON
    (48) statement1 -> . lectura SEMICOLON
    (49) statement1 -> . escritura SEMICOLON
    (50) statement1 -> . for
    (51) statement1 -> . if
    (52) statement1 -> . while
    (100) empty -> .
    (53) asignacion -> . ID EQUALS exp
    (54) asignacion -> . ID arr EQUALS exp
    (55) asignacion -> . ID mat EQUALS exp
    (61) llamada -> . ID LPAREN exp RPAREN
    (76) lectura -> . READ LPAREN var1 RPAREN
    (69) escritura -> . PRINT LPAREN escritura1 RPAREN
    (66) for -> . FOR LPAREN for1 RPAREN LCURLY statement RCURLY
    (62) if -> . IF LPAREN exp RPAREN LCURLY statement RCURLY
    (63) if -> . IF LPAREN exp RPAREN LCURLY statement RCURLY else
    (68) while -> . WHILE LPAREN exp RPAREN LCURLY statement RCURLY

    RCURLY          reduce using rule 100 (empty -> .)
    ID              shift and go to state 131
    READ            shift and go to state 132
    PRINT           shift and go to state 133
    FOR             shift and go to state 134
    IF              shift and go to state 135
    WHILE           shift and go to state 136

    statement                      shift and go to state 200
    statement1                     shift and go to state 122
    empty                          shift and go to state 123
    asignacion                     shift and go to state 124
    llamada                        shift and go to state 125
    lectura                        shift and go to state 126
    escritura                      shift and go to state 127
    for                            shift and go to state 128
    if                             shift and go to state 129
    while                          shift and go to state 130

state 195

    (67) for1 -> FROM asignacion TO . exp
    (77) exp -> . nexp
    (78) exp -> . nexp OR nexp
    (79) nexp -> . compexp
    (80) nexp -> . compexp AND compexp
    (81) compexp -> . sumexp
    (82) compexp -> . compexp1 sumexp
    (88) sumexp -> . mulexp
    (89) sumexp -> . mulexp PLUS mulexp
    (90) sumexp -> . mulexp MINUS mulexp
    (83) compexp1 -> . sumexp GT sumexp
    (84) compexp1 -> . sumexp LT sumexp
    (85) compexp1 -> . sumexp GTE sumexp
    (86) compexp1 -> . sumexp LTE sumexp
    (87) compexp1 -> . sumexp NE sumexp
    (91) mulexp -> . pexp
    (92) mulexp -> . pexp MUL pexp
    (93) mulexp -> . pexp DIV pexp
    (94) pexp -> . var1
    (95) pexp -> . CTEI
    (96) pexp -> . CTEF
    (97) pexp -> . CTEC
    (98) pexp -> . llamada
    (99) pexp -> . LPAREN exp RPAREN
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (61) llamada -> . ID LPAREN exp RPAREN
    (100) empty -> .

    CTEI            shift and go to state 93
    CTEF            shift and go to state 67
    CTEC            shift and go to state 68
    LPAREN          shift and go to state 70
    ID              shift and go to state 71
    MUL             reduce using rule 100 (empty -> .)
    DIV             reduce using rule 100 (empty -> .)
    PLUS            reduce using rule 100 (empty -> .)
    MINUS           reduce using rule 100 (empty -> .)
    GT              reduce using rule 100 (empty -> .)
    LT              reduce using rule 100 (empty -> .)
    GTE             reduce using rule 100 (empty -> .)
    LTE             reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    RPAREN          reduce using rule 100 (empty -> .)

    exp                            shift and go to state 201
    nexp                           shift and go to state 60
    compexp                        shift and go to state 61
    sumexp                         shift and go to state 62
    compexp1                       shift and go to state 63
    mulexp                         shift and go to state 64
    pexp                           shift and go to state 65
    var1                           shift and go to state 66
    llamada                        shift and go to state 69
    empty                          shift and go to state 44

state 196

    (62) if -> IF LPAREN exp RPAREN LCURLY . statement RCURLY
    (63) if -> IF LPAREN exp RPAREN LCURLY . statement RCURLY else
    (44) statement -> . statement1 statement
    (45) statement -> . empty
    (46) statement1 -> . asignacion SEMICOLON
    (47) statement1 -> . llamada SEMICOLON
    (48) statement1 -> . lectura SEMICOLON
    (49) statement1 -> . escritura SEMICOLON
    (50) statement1 -> . for
    (51) statement1 -> . if
    (52) statement1 -> . while
    (100) empty -> .
    (53) asignacion -> . ID EQUALS exp
    (54) asignacion -> . ID arr EQUALS exp
    (55) asignacion -> . ID mat EQUALS exp
    (61) llamada -> . ID LPAREN exp RPAREN
    (76) lectura -> . READ LPAREN var1 RPAREN
    (69) escritura -> . PRINT LPAREN escritura1 RPAREN
    (66) for -> . FOR LPAREN for1 RPAREN LCURLY statement RCURLY
    (62) if -> . IF LPAREN exp RPAREN LCURLY statement RCURLY
    (63) if -> . IF LPAREN exp RPAREN LCURLY statement RCURLY else
    (68) while -> . WHILE LPAREN exp RPAREN LCURLY statement RCURLY

    RCURLY          reduce using rule 100 (empty -> .)
    ID              shift and go to state 131
    READ            shift and go to state 132
    PRINT           shift and go to state 133
    FOR             shift and go to state 134
    IF              shift and go to state 135
    WHILE           shift and go to state 136

    statement                      shift and go to state 202
    statement1                     shift and go to state 122
    empty                          shift and go to state 123
    asignacion                     shift and go to state 124
    llamada                        shift and go to state 125
    lectura                        shift and go to state 126
    escritura                      shift and go to state 127
    for                            shift and go to state 128
    if                             shift and go to state 129
    while                          shift and go to state 130

state 197

    (68) while -> WHILE LPAREN exp RPAREN LCURLY . statement RCURLY
    (44) statement -> . statement1 statement
    (45) statement -> . empty
    (46) statement1 -> . asignacion SEMICOLON
    (47) statement1 -> . llamada SEMICOLON
    (48) statement1 -> . lectura SEMICOLON
    (49) statement1 -> . escritura SEMICOLON
    (50) statement1 -> . for
    (51) statement1 -> . if
    (52) statement1 -> . while
    (100) empty -> .
    (53) asignacion -> . ID EQUALS exp
    (54) asignacion -> . ID arr EQUALS exp
    (55) asignacion -> . ID mat EQUALS exp
    (61) llamada -> . ID LPAREN exp RPAREN
    (76) lectura -> . READ LPAREN var1 RPAREN
    (69) escritura -> . PRINT LPAREN escritura1 RPAREN
    (66) for -> . FOR LPAREN for1 RPAREN LCURLY statement RCURLY
    (62) if -> . IF LPAREN exp RPAREN LCURLY statement RCURLY
    (63) if -> . IF LPAREN exp RPAREN LCURLY statement RCURLY else
    (68) while -> . WHILE LPAREN exp RPAREN LCURLY statement RCURLY

    RCURLY          reduce using rule 100 (empty -> .)
    ID              shift and go to state 131
    READ            shift and go to state 132
    PRINT           shift and go to state 133
    FOR             shift and go to state 134
    IF              shift and go to state 135
    WHILE           shift and go to state 136

    statement                      shift and go to state 203
    statement1                     shift and go to state 122
    empty                          shift and go to state 123
    asignacion                     shift and go to state 124
    llamada                        shift and go to state 125
    lectura                        shift and go to state 126
    escritura                      shift and go to state 127
    for                            shift and go to state 128
    if                             shift and go to state 129
    while                          shift and go to state 130

state 198

    (42) function1 -> ID save_fun LPAREN param RPAREN SEMICOLON LCURLY vars statement . RCURLY

    RCURLY          shift and go to state 204


state 199

    (43) function2 -> ID save_fun LPAREN param RPAREN SEMICOLON LCURLY vars statement . RETURN exp SEMICOLON RCURLY

    RETURN          shift and go to state 205


state 200

    (66) for -> FOR LPAREN for1 RPAREN LCURLY statement . RCURLY

    RCURLY          shift and go to state 206


state 201

    (67) for1 -> FROM asignacion TO exp .

    RPAREN          reduce using rule 67 (for1 -> FROM asignacion TO exp .)


state 202

    (62) if -> IF LPAREN exp RPAREN LCURLY statement . RCURLY
    (63) if -> IF LPAREN exp RPAREN LCURLY statement . RCURLY else

    RCURLY          shift and go to state 207


state 203

    (68) while -> WHILE LPAREN exp RPAREN LCURLY statement . RCURLY

    RCURLY          shift and go to state 208


state 204

    (42) function1 -> ID save_fun LPAREN param RPAREN SEMICOLON LCURLY vars statement RCURLY .

    FUN             reduce using rule 42 (function1 -> ID save_fun LPAREN param RPAREN SEMICOLON LCURLY vars statement RCURLY .)
    MAIN            reduce using rule 42 (function1 -> ID save_fun LPAREN param RPAREN SEMICOLON LCURLY vars statement RCURLY .)
    $end            reduce using rule 42 (function1 -> ID save_fun LPAREN param RPAREN SEMICOLON LCURLY vars statement RCURLY .)


state 205

    (43) function2 -> ID save_fun LPAREN param RPAREN SEMICOLON LCURLY vars statement RETURN . exp SEMICOLON RCURLY
    (77) exp -> . nexp
    (78) exp -> . nexp OR nexp
    (79) nexp -> . compexp
    (80) nexp -> . compexp AND compexp
    (81) compexp -> . sumexp
    (82) compexp -> . compexp1 sumexp
    (88) sumexp -> . mulexp
    (89) sumexp -> . mulexp PLUS mulexp
    (90) sumexp -> . mulexp MINUS mulexp
    (83) compexp1 -> . sumexp GT sumexp
    (84) compexp1 -> . sumexp LT sumexp
    (85) compexp1 -> . sumexp GTE sumexp
    (86) compexp1 -> . sumexp LTE sumexp
    (87) compexp1 -> . sumexp NE sumexp
    (91) mulexp -> . pexp
    (92) mulexp -> . pexp MUL pexp
    (93) mulexp -> . pexp DIV pexp
    (94) pexp -> . var1
    (95) pexp -> . CTEI
    (96) pexp -> . CTEF
    (97) pexp -> . CTEC
    (98) pexp -> . llamada
    (99) pexp -> . LPAREN exp RPAREN
    (14) var1 -> . ID
    (15) var1 -> . ID COMMA var1
    (16) var1 -> . ID arr
    (17) var1 -> . ID arr COMMA var1
    (18) var1 -> . ID mat COMMA var1
    (19) var1 -> . ID mat
    (20) var1 -> . ID mat especial
    (21) var1 -> . empty
    (61) llamada -> . ID LPAREN exp RPAREN
    (100) empty -> .

    CTEI            shift and go to state 93
    CTEF            shift and go to state 67
    CTEC            shift and go to state 68
    LPAREN          shift and go to state 70
    ID              shift and go to state 71
    MUL             reduce using rule 100 (empty -> .)
    DIV             reduce using rule 100 (empty -> .)
    PLUS            reduce using rule 100 (empty -> .)
    MINUS           reduce using rule 100 (empty -> .)
    GT              reduce using rule 100 (empty -> .)
    LT              reduce using rule 100 (empty -> .)
    GTE             reduce using rule 100 (empty -> .)
    LTE             reduce using rule 100 (empty -> .)
    NE              reduce using rule 100 (empty -> .)
    AND             reduce using rule 100 (empty -> .)
    OR              reduce using rule 100 (empty -> .)
    SEMICOLON       reduce using rule 100 (empty -> .)

    exp                            shift and go to state 209
    nexp                           shift and go to state 60
    compexp                        shift and go to state 61
    sumexp                         shift and go to state 62
    compexp1                       shift and go to state 63
    mulexp                         shift and go to state 64
    pexp                           shift and go to state 65
    var1                           shift and go to state 66
    llamada                        shift and go to state 69
    empty                          shift and go to state 44

state 206

    (66) for -> FOR LPAREN for1 RPAREN LCURLY statement RCURLY .

    ID              reduce using rule 66 (for -> FOR LPAREN for1 RPAREN LCURLY statement RCURLY .)
    READ            reduce using rule 66 (for -> FOR LPAREN for1 RPAREN LCURLY statement RCURLY .)
    PRINT           reduce using rule 66 (for -> FOR LPAREN for1 RPAREN LCURLY statement RCURLY .)
    FOR             reduce using rule 66 (for -> FOR LPAREN for1 RPAREN LCURLY statement RCURLY .)
    IF              reduce using rule 66 (for -> FOR LPAREN for1 RPAREN LCURLY statement RCURLY .)
    WHILE           reduce using rule 66 (for -> FOR LPAREN for1 RPAREN LCURLY statement RCURLY .)
    RCURLY          reduce using rule 66 (for -> FOR LPAREN for1 RPAREN LCURLY statement RCURLY .)
    RETURN          reduce using rule 66 (for -> FOR LPAREN for1 RPAREN LCURLY statement RCURLY .)


state 207

    (62) if -> IF LPAREN exp RPAREN LCURLY statement RCURLY .
    (63) if -> IF LPAREN exp RPAREN LCURLY statement RCURLY . else
    (64) else -> . ELSE LCURLY statement RCURLY
    (65) else -> . empty
    (100) empty -> .

  ! reduce/reduce conflict for ID resolved using rule 62 (if -> IF LPAREN exp RPAREN LCURLY statement RCURLY .)
  ! reduce/reduce conflict for READ resolved using rule 62 (if -> IF LPAREN exp RPAREN LCURLY statement RCURLY .)
  ! reduce/reduce conflict for PRINT resolved using rule 62 (if -> IF LPAREN exp RPAREN LCURLY statement RCURLY .)
  ! reduce/reduce conflict for FOR resolved using rule 62 (if -> IF LPAREN exp RPAREN LCURLY statement RCURLY .)
  ! reduce/reduce conflict for IF resolved using rule 62 (if -> IF LPAREN exp RPAREN LCURLY statement RCURLY .)
  ! reduce/reduce conflict for WHILE resolved using rule 62 (if -> IF LPAREN exp RPAREN LCURLY statement RCURLY .)
  ! reduce/reduce conflict for RCURLY resolved using rule 62 (if -> IF LPAREN exp RPAREN LCURLY statement RCURLY .)
  ! reduce/reduce conflict for RETURN resolved using rule 62 (if -> IF LPAREN exp RPAREN LCURLY statement RCURLY .)
    ID              reduce using rule 62 (if -> IF LPAREN exp RPAREN LCURLY statement RCURLY .)
    READ            reduce using rule 62 (if -> IF LPAREN exp RPAREN LCURLY statement RCURLY .)
    PRINT           reduce using rule 62 (if -> IF LPAREN exp RPAREN LCURLY statement RCURLY .)
    FOR             reduce using rule 62 (if -> IF LPAREN exp RPAREN LCURLY statement RCURLY .)
    IF              reduce using rule 62 (if -> IF LPAREN exp RPAREN LCURLY statement RCURLY .)
    WHILE           reduce using rule 62 (if -> IF LPAREN exp RPAREN LCURLY statement RCURLY .)
    RCURLY          reduce using rule 62 (if -> IF LPAREN exp RPAREN LCURLY statement RCURLY .)
    RETURN          reduce using rule 62 (if -> IF LPAREN exp RPAREN LCURLY statement RCURLY .)
    ELSE            shift and go to state 211

  ! ID              [ reduce using rule 100 (empty -> .) ]
  ! READ            [ reduce using rule 100 (empty -> .) ]
  ! PRINT           [ reduce using rule 100 (empty -> .) ]
  ! FOR             [ reduce using rule 100 (empty -> .) ]
  ! IF              [ reduce using rule 100 (empty -> .) ]
  ! WHILE           [ reduce using rule 100 (empty -> .) ]
  ! RCURLY          [ reduce using rule 100 (empty -> .) ]
  ! RETURN          [ reduce using rule 100 (empty -> .) ]

    else                           shift and go to state 210
    empty                          shift and go to state 212

state 208

    (68) while -> WHILE LPAREN exp RPAREN LCURLY statement RCURLY .

    ID              reduce using rule 68 (while -> WHILE LPAREN exp RPAREN LCURLY statement RCURLY .)
    READ            reduce using rule 68 (while -> WHILE LPAREN exp RPAREN LCURLY statement RCURLY .)
    PRINT           reduce using rule 68 (while -> WHILE LPAREN exp RPAREN LCURLY statement RCURLY .)
    FOR             reduce using rule 68 (while -> WHILE LPAREN exp RPAREN LCURLY statement RCURLY .)
    IF              reduce using rule 68 (while -> WHILE LPAREN exp RPAREN LCURLY statement RCURLY .)
    WHILE           reduce using rule 68 (while -> WHILE LPAREN exp RPAREN LCURLY statement RCURLY .)
    RCURLY          reduce using rule 68 (while -> WHILE LPAREN exp RPAREN LCURLY statement RCURLY .)
    RETURN          reduce using rule 68 (while -> WHILE LPAREN exp RPAREN LCURLY statement RCURLY .)


state 209

    (43) function2 -> ID save_fun LPAREN param RPAREN SEMICOLON LCURLY vars statement RETURN exp . SEMICOLON RCURLY

    SEMICOLON       shift and go to state 213


state 210

    (63) if -> IF LPAREN exp RPAREN LCURLY statement RCURLY else .

    ID              reduce using rule 63 (if -> IF LPAREN exp RPAREN LCURLY statement RCURLY else .)
    READ            reduce using rule 63 (if -> IF LPAREN exp RPAREN LCURLY statement RCURLY else .)
    PRINT           reduce using rule 63 (if -> IF LPAREN exp RPAREN LCURLY statement RCURLY else .)
    FOR             reduce using rule 63 (if -> IF LPAREN exp RPAREN LCURLY statement RCURLY else .)
    IF              reduce using rule 63 (if -> IF LPAREN exp RPAREN LCURLY statement RCURLY else .)
    WHILE           reduce using rule 63 (if -> IF LPAREN exp RPAREN LCURLY statement RCURLY else .)
    RCURLY          reduce using rule 63 (if -> IF LPAREN exp RPAREN LCURLY statement RCURLY else .)
    RETURN          reduce using rule 63 (if -> IF LPAREN exp RPAREN LCURLY statement RCURLY else .)


state 211

    (64) else -> ELSE . LCURLY statement RCURLY

    LCURLY          shift and go to state 214


state 212

    (65) else -> empty .

    ID              reduce using rule 65 (else -> empty .)
    READ            reduce using rule 65 (else -> empty .)
    PRINT           reduce using rule 65 (else -> empty .)
    FOR             reduce using rule 65 (else -> empty .)
    IF              reduce using rule 65 (else -> empty .)
    WHILE           reduce using rule 65 (else -> empty .)
    RCURLY          reduce using rule 65 (else -> empty .)
    RETURN          reduce using rule 65 (else -> empty .)


state 213

    (43) function2 -> ID save_fun LPAREN param RPAREN SEMICOLON LCURLY vars statement RETURN exp SEMICOLON . RCURLY

    RCURLY          shift and go to state 215


state 214

    (64) else -> ELSE LCURLY . statement RCURLY
    (44) statement -> . statement1 statement
    (45) statement -> . empty
    (46) statement1 -> . asignacion SEMICOLON
    (47) statement1 -> . llamada SEMICOLON
    (48) statement1 -> . lectura SEMICOLON
    (49) statement1 -> . escritura SEMICOLON
    (50) statement1 -> . for
    (51) statement1 -> . if
    (52) statement1 -> . while
    (100) empty -> .
    (53) asignacion -> . ID EQUALS exp
    (54) asignacion -> . ID arr EQUALS exp
    (55) asignacion -> . ID mat EQUALS exp
    (61) llamada -> . ID LPAREN exp RPAREN
    (76) lectura -> . READ LPAREN var1 RPAREN
    (69) escritura -> . PRINT LPAREN escritura1 RPAREN
    (66) for -> . FOR LPAREN for1 RPAREN LCURLY statement RCURLY
    (62) if -> . IF LPAREN exp RPAREN LCURLY statement RCURLY
    (63) if -> . IF LPAREN exp RPAREN LCURLY statement RCURLY else
    (68) while -> . WHILE LPAREN exp RPAREN LCURLY statement RCURLY

    RCURLY          reduce using rule 100 (empty -> .)
    ID              shift and go to state 131
    READ            shift and go to state 132
    PRINT           shift and go to state 133
    FOR             shift and go to state 134
    IF              shift and go to state 135
    WHILE           shift and go to state 136

    statement                      shift and go to state 216
    statement1                     shift and go to state 122
    empty                          shift and go to state 123
    asignacion                     shift and go to state 124
    llamada                        shift and go to state 125
    lectura                        shift and go to state 126
    escritura                      shift and go to state 127
    for                            shift and go to state 128
    if                             shift and go to state 129
    while                          shift and go to state 130

state 215

    (43) function2 -> ID save_fun LPAREN param RPAREN SEMICOLON LCURLY vars statement RETURN exp SEMICOLON RCURLY .

    FUN             reduce using rule 43 (function2 -> ID save_fun LPAREN param RPAREN SEMICOLON LCURLY vars statement RETURN exp SEMICOLON RCURLY .)
    MAIN            reduce using rule 43 (function2 -> ID save_fun LPAREN param RPAREN SEMICOLON LCURLY vars statement RETURN exp SEMICOLON RCURLY .)
    $end            reduce using rule 43 (function2 -> ID save_fun LPAREN param RPAREN SEMICOLON LCURLY vars statement RETURN exp SEMICOLON RCURLY .)


state 216

    (64) else -> ELSE LCURLY statement . RCURLY

    RCURLY          shift and go to state 217


state 217

    (64) else -> ELSE LCURLY statement RCURLY .

    ID              reduce using rule 64 (else -> ELSE LCURLY statement RCURLY .)
    READ            reduce using rule 64 (else -> ELSE LCURLY statement RCURLY .)
    PRINT           reduce using rule 64 (else -> ELSE LCURLY statement RCURLY .)
    FOR             reduce using rule 64 (else -> ELSE LCURLY statement RCURLY .)
    IF              reduce using rule 64 (else -> ELSE LCURLY statement RCURLY .)
    WHILE           reduce using rule 64 (else -> ELSE LCURLY statement RCURLY .)
    RCURLY          reduce using rule 64 (else -> ELSE LCURLY statement RCURLY .)
    RETURN          reduce using rule 64 (else -> ELSE LCURLY statement RCURLY .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for MAIN in state 5 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 43 resolved as shift
WARNING: shift/reduce conflict for ID in state 55 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 56 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 57 resolved as shift
WARNING: shift/reduce conflict for RBRACKET in state 58 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 64 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 64 resolved as shift
WARNING: shift/reduce conflict for MUL in state 65 resolved as shift
WARNING: shift/reduce conflict for DIV in state 65 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 71 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 71 resolved as shift
WARNING: shift/reduce conflict for ID in state 77 resolved as shift
WARNING: shift/reduce conflict for ID in state 78 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 87 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 87 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 87 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 87 resolved as shift
WARNING: shift/reduce conflict for ID in state 87 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 88 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 88 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 88 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 88 resolved as shift
WARNING: shift/reduce conflict for ID in state 88 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 89 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 89 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 89 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 89 resolved as shift
WARNING: shift/reduce conflict for ID in state 89 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 90 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 90 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 90 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 90 resolved as shift
WARNING: shift/reduce conflict for ID in state 90 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 91 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 91 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 91 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 91 resolved as shift
WARNING: shift/reduce conflict for ID in state 91 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 94 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 94 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 94 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 94 resolved as shift
WARNING: shift/reduce conflict for ID in state 94 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 95 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 95 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 95 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 95 resolved as shift
WARNING: shift/reduce conflict for ID in state 95 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 96 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 96 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 96 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 96 resolved as shift
WARNING: shift/reduce conflict for ID in state 96 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 97 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 97 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 97 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 97 resolved as shift
WARNING: shift/reduce conflict for ID in state 97 resolved as shift
WARNING: shift/reduce conflict for RBRACKET in state 139 resolved as shift
WARNING: shift/reduce conflict for RBRACKET in state 142 resolved as shift
WARNING: reduce/reduce conflict in state 172 resolved using rule (escritura2 -> CTEI)
WARNING: rejected rule (pexp -> CTEI) in state 172
WARNING: reduce/reduce conflict in state 173 resolved using rule (escritura2 -> CTEF)
WARNING: rejected rule (pexp -> CTEF) in state 173
WARNING: reduce/reduce conflict in state 207 resolved using rule (if -> IF LPAREN exp RPAREN LCURLY statement RCURLY)
WARNING: rejected rule (empty -> <empty>) in state 207
